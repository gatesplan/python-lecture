<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: 출력 예측 (정렬 과정) - 워밍업 -->
  <problem>
    <description>다음 선택 정렬 코드의 출력 결과를 쓰세요.</description>
    <code><![CDATA[A = [5, 2, 8, 1]
n = len(A)

for i in range(n-1):
    m = i
    for j in range(i+1, n):
        if A[j] < A[m]:
            m = j
    A[i], A[m] = A[m], A[i]
    print(A[i], end=' ')

print()]]></code>
    <input></input>
    <output><![CDATA[1 2 5 8]]></output>
    <solution><![CDATA[# 선택 정렬 과정:
# 초기: [5, 2, 8, 1]
#
# i=0: 최솟값 1을 찾아 첫 위치와 교환
#      [1, 2, 8, 5] → 출력: 1
#
# i=1: 나머지 중 최솟값 2 (이미 제자리)
#      [1, 2, 8, 5] → 출력: 2
#
# i=2: 나머지 중 최솟값 5를 찾아 교환
#      [1, 2, 5, 8] → 출력: 5
#
# 마지막 원소(8)는 자동 정렬
# 최종 출력: 1 2 5 8 (공백으로 구분)
#
# 정답: 1 2 5 8]]></solution>
  </problem>

  <!-- 문제 2: 복잡도 분석 (선택 정렬) -->
  <problem>
    <description>선택 정렬(Selection Sort)의 시간복잡도를 Big-O로 쓰고, 최선/평균/최악의 경우가 모두 같은 이유를 설명하세요.</description>
    <code><![CDATA[def f(A):
    n = len(A)
    for i in range(n-1):
        m = i
        for j in range(i+1, n):
            if A[j] < A[m]:
                m = j
        A[i], A[m] = A[m], A[i]]]></code>
    <input></input>
    <output><![CDATA[O(n²)]]></output>
    <solution><![CDATA[# 시간복잡도: O(n²)
#
# 연산 횟수 분석:
# - 외부 루프: n-1번
# - 내부 루프 (i=0): n-1번
# - 내부 루프 (i=1): n-2번
# - 내부 루프 (i=2): n-3번
# - ...
# - 내부 루프 (i=n-2): 1번
#
# 총 비교 횟수:
# (n-1) + (n-2) + (n-3) + ... + 1
# = n(n-1)/2
# ≈ n²/2
# → O(n²)
#
# 최선/평균/최악이 모두 O(n²)인 이유:
# - 이미 정렬되어 있어도 모든 원소를 비교해야 함
# - 최솟값을 찾기 위해 남은 모든 원소를 확인
# - 입력 상태와 무관하게 항상 같은 횟수 비교
#
# 예시 (n=4):
# - 정렬됨 [1,2,3,4]: 3+2+1 = 6번 비교
# - 역순 [4,3,2,1]: 3+2+1 = 6번 비교
# - 항상 같음!
#
# 정답: O(n²) (최선=평균=최악)]]></solution>
  </problem>

  <!-- 문제 3: 복잡도 분석 (버블 정렬) -->
  <problem>
    <description>버블 정렬(Bubble Sort)의 최악의 경우 시간복잡도를 Big-O로 쓰세요.</description>
    <code><![CDATA[def f(A):
    n = len(A)
    for i in range(n):
        for j in range(n-i-1):
            if A[j] > A[j+1]:
                A[j], A[j+1] = A[j+1], A[j]]]></code>
    <input></input>
    <output><![CDATA[O(n²)]]></output>
    <solution><![CDATA[# 시간복잡도: O(n²)
#
# 연산 횟수 분석 (최악의 경우):
# - 외부 루프: n번
# - 내부 루프 (i=0): n-1번
# - 내부 루프 (i=1): n-2번
# - ...
# - 내부 루프 (i=n-1): 0번
#
# 총 비교 횟수:
# (n-1) + (n-2) + ... + 1 + 0
# = n(n-1)/2
# → O(n²)
#
# 최악의 경우:
# - 배열이 역순 정렬되어 있을 때
# - 예: [5,4,3,2,1]
# - 매번 교환 발생
# - 비교 횟수 = 교환 횟수 = n(n-1)/2
#
# 최선의 경우:
# - 이미 정렬되어 있을 때
# - 예: [1,2,3,4,5]
# - 비교는 n(n-1)/2번 (변함없음)
# - 교환은 0번
# - 최적화 버전에서는 O(n) 가능
#
# 정답: O(n²)]]></solution>
  </problem>

  <!-- 문제 4: 복잡도 분석 (삽입 정렬 - 최선/최악) -->
  <problem>
    <description>삽입 정렬(Insertion Sort)의 최선의 경우와 최악의 경우 시간복잡도를 각각 Big-O로 쓰고, 언제 그런 경우가 발생하는지 설명하세요.</description>
    <code><![CDATA[def f(A):
    n = len(A)
    for i in range(1, n):
        k = A[i]
        j = i - 1
        while j >= 0 and A[j] > k:
            A[j+1] = A[j]
            j -= 1
        A[j+1] = k]]></code>
    <input></input>
    <output><![CDATA[최선: O(n), 최악: O(n²)]]></output>
    <solution><![CDATA[# 삽입 정렬의 시간복잡도
#
# 최선의 경우: O(n)
# - 언제: 배열이 이미 정렬되어 있을 때
# - 예: [1, 2, 3, 4, 5]
# - 각 원소마다 while 루프가 0번 실행
# - 외부 루프만 n-1번 → O(n)
#
# 구체적 예시 (정렬됨):
# i=1: A[1]=2, j=0, A[0]=1 < 2 → while 진입 안함
# i=2: A[2]=3, j=1, A[1]=2 < 3 → while 진입 안함
# ...
# 각 원소당 1번씩만 비교 → 총 n번
#
# 최악의 경우: O(n²)
# - 언제: 배열이 역순 정렬되어 있을 때
# - 예: [5, 4, 3, 2, 1]
# - 각 원소마다 while 루프가 i번 실행
# - 1 + 2 + 3 + ... + (n-1) = n(n-1)/2 → O(n²)
#
# 구체적 예시 (역순):
# i=1: A[1]=4, 1번 이동
# i=2: A[2]=3, 2번 이동
# i=3: A[3]=2, 3번 이동
# i=4: A[4]=1, 4번 이동
# 총: 1+2+3+4 = 10번
#
# 평균의 경우: O(n²)
#
# 특징:
# - 거의 정렬된 배열에서 매우 효율적
# - 온라인 정렬 가능 (데이터가 들어오면서 정렬)
#
# 정답: 최선 O(n), 최악 O(n²)]]></solution>
  </problem>

  <!-- 문제 5: 복잡도 분석 (퀵 정렬 - 평균/최악) -->
  <problem>
    <description>퀵 정렬(Quick Sort)의 평균과 최악의 경우 시간복잡도를 각각 Big-O로 쓰고, 최악의 경우가 발생하는 상황을 설명하세요.</description>
    <code><![CDATA[def f(A):
    if len(A) <= 1:
        return A

    p = A[len(A)//2]
    L = [x for x in A if x < p]
    M = [x for x in A if x == p]
    R = [x for x in A if x > p]

    return f(L) + M + f(R)]]></code>
    <input></input>
    <output><![CDATA[평균: O(n log n), 최악: O(n²)]]></output>
    <solution><![CDATA[# 퀵 정렬의 시간복잡도
#
# 평균의 경우: O(n log n)
# - 피벗이 중간값에 가까울 때
# - 배열이 균등하게 분할됨
# - 재귀 깊이: log n
# - 각 단계에서 분할: O(n)
# - 총: n × log n
#
# 구체적 예시:
# [3,6,8,10,1,2,1] (피벗=10)
# → L=[3,6,8,1,2,1], M=[10], R=[]
# → 균등 분할 시 log n 단계
#
# 최악의 경우: O(n²)
# - 언제: 피벗이 항상 최소 또는 최대값일 때
# - 한쪽으로만 분할됨
# - 재귀 깊이: n
# - 각 단계에서 분할: O(n)
# - 총: n × n = n²
#
# 최악의 예시:
# [1,2,3,4,5] (이미 정렬됨, 피벗=3)
# → L=[1,2], M=[3], R=[4,5]
# 피벗이 항상 끝에 있으면:
# n → (n-1) → (n-2) → ... → 1
# 총: n + (n-1) + ... + 1 = n(n+1)/2 → O(n²)
#
# 최악을 피하는 방법:
# 1. 랜덤 피벗 선택
# 2. 중간값의 중간값(Median of Medians)
# 3. 3개 값의 중간값 선택
#
# 실전:
# - 평균적으로 가장 빠른 정렬
# - 캐시 효율성 좋음
# - 제자리 정렬 가능
#
# 정답: 평균 O(n log n), 최악 O(n²)]]></solution>
  </problem>

  <!-- 문제 6: 복잡도 분석 (병합 정렬) -->
  <problem>
    <description>병합 정렬(Merge Sort)의 시간복잡도를 Big-O로 쓰고, 최선/평균/최악이 모두 같은 이유를 설명하세요.</description>
    <code><![CDATA[def f(A):
    if len(A) <= 1:
        return A

    m = len(A) // 2
    L = f(A[:m])
    R = f(A[m:])

    return merge(L, R)

def merge(L, R):
    res = []
    i = j = 0
    while i < len(L) and j < len(R):
        if L[i] <= R[j]:
            res.append(L[i])
            i += 1
        else:
            res.append(R[j])
            j += 1
    res.extend(L[i:])
    res.extend(R[j:])
    return res]]></code>
    <input></input>
    <output><![CDATA[O(n log n)]]></output>
    <solution><![CDATA[# 병합 정렬의 시간복잡도: O(n log n)
#
# 복잡도 분석:
# 1. 분할 단계:
#    - 배열을 절반씩 나눔
#    - 깊이: log₂(n)
#    - 예: n=8 → 8→4→2→1 (3단계, log₂8=3)
#
# 2. 병합 단계:
#    - 각 단계에서 n개 원소를 병합
#    - 병합은 O(n) (두 배열 순회)
#
# 3. 전체:
#    - 깊이 log n × 각 단계 O(n)
#    - 총: n × log n
#
# 구체적 예시 (n=8):
# 레벨 0: [8개] 병합 → 8번 연산
# 레벨 1: [4개][4개] 병합 → 4+4 = 8번
# 레벨 2: [2개][2개][2개][2개] 병합 → 2+2+2+2 = 8번
# 레벨 3: [1][1][1][1][1][1][1][1] → 병합 없음
# 총: 8 × 3 = 24번 = n × log n
#
# 최선/평균/최악이 모두 O(n log n)인 이유:
# - 항상 배열을 절반씩 나눔
# - 입력 상태와 무관하게 분할 구조 동일
# - 병합 시 항상 모든 원소 비교
# - 이미 정렬되어 있어도 같은 과정
#
# 예시:
# - [1,2,3,4]: O(n log n)
# - [4,3,2,1]: O(n log n)
# - [3,1,4,2]: O(n log n)
# - 항상 같음!
#
# 특징:
# - 안정 정렬 (Stable Sort)
# - 최악의 경우에도 보장된 성능
# - 추가 메모리 O(n) 필요
# - 큰 데이터셋에 적합
#
# 정답: O(n log n) (최선=평균=최악)]]></solution>
  </problem>

  <!-- 문제 7: 서술형 (안정 정렬 개념) -->
  <problem>
    <description>안정 정렬(Stable Sort)의 개념을 설명하고, 버블 정렬과 선택 정렬 중 어느 것이 안정 정렬인지 이유와 함께 답하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 안정 정렬(Stable Sort) 개념
#
# 정의:
# - 같은 값을 가진 원소들의 상대적 순서가
#   정렬 후에도 유지되는 정렬
#
# 예시:
# 입력: [3a, 1, 3b, 2] (3a, 3b는 같은 값 3)
# - 안정 정렬: [1, 2, 3a, 3b] (순서 유지)
# - 불안정 정렬: [1, 2, 3b, 3a] (순서 바뀜)
#
# 왜 중요한가?
# - 여러 기준으로 정렬할 때 필요
# - 예: 이름순 정렬 후 나이순 정렬
#        → 같은 나이는 이름순 유지
#
# 버블 정렬 vs 선택 정렬:
#
# 1. 버블 정렬: 안정 정렬 ✓
#    for i in range(n):
#        for j in range(n-i-1):
#            if A[j] > A[j+1]:  # > (초과)만 교환
#                swap(A[j], A[j+1])
#
#    - 같은 값은 교환하지 않음 (>만 교환)
#    - 인접한 원소만 비교
#    - 상대적 순서 유지
#
#    예: [3a, 1, 3b, 2]
#    → [1, 3a, 2, 3b]
#    → [1, 2, 3a, 3b] (순서 유지!)
#
# 2. 선택 정렬: 불안정 정렬 ✗
#    for i in range(n-1):
#        m = i
#        for j in range(i+1, n):
#            if A[j] < A[m]:
#                m = j
#        swap(A[i], A[m])  # 멀리 떨어진 원소와 교환
#
#    - 최솟값을 찾아 첫 위치와 교환
#    - 멀리 떨어진 원소와 교환 → 순서 깨짐
#
#    예: [3a, 1, 3b, 2]
#    i=0: 최솟값 1과 3a 교환 → [1, 3a, 3b, 2]
#    i=1: 최솟값 2와 3a 교환 → [1, 2, 3b, 3a]
#    결과: [1, 2, 3a, 3b] → 3b가 3a보다 앞! (불안정)
#
# 정리:
# - 버블 정렬: 안정 (인접 비교만)
# - 선택 정렬: 불안정 (멀리 교환)
# - 삽입 정렬: 안정
# - 병합 정렬: 안정
# - 퀵 정렬: 일반적으로 불안정
#
# 정답: 버블 정렬이 안정 정렬]]></solution>
  </problem>

  <!-- 문제 8: 코드 비교 (O(n²) vs O(n log n)) -->
  <problem>
    <description>배열 크기가 10,000일 때 선택 정렬과 병합 정렬의 대략적인 연산 횟수를 비교하고, 성능 차이를 설명하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# n = 10,000일 때 연산 횟수 비교
#
# 1. 선택 정렬 (O(n²)):
#    - 복잡도: n(n-1)/2
#    - 연산 횟수: 10,000 × 9,999 / 2
#                = 99,990,000 / 2
#                = 49,995,000번
#                ≈ 5천만 번
#
# 2. 병합 정렬 (O(n log n)):
#    - 복잡도: n × log₂(n)
#    - log₂(10,000) ≈ 13.3
#    - 연산 횟수: 10,000 × 13.3
#                ≈ 133,000번
#                ≈ 13만 번
#
# 성능 차이:
# - 선택 정렬: 약 5천만 번
# - 병합 정렬: 약 13만 번
# - 차이: 5천만 / 13만 ≈ 385배
#
# 실행 시간 예상 (1억 연산/초 가정):
# - 선택 정렬: 약 0.5초
# - 병합 정렬: 약 0.0013초
#
# n이 더 크면:
# n = 100,000:
# - 선택 정렬: 약 50억 번 (50초)
# - 병합 정렬: 약 170만 번 (0.017초)
# - 약 3,000배 차이!
#
# n = 1,000,000:
# - 선택 정렬: 약 5천억 번 (5,000초 = 83분)
# - 병합 정렬: 약 2천만 번 (0.2초)
# - 약 25,000배 차이!
#
# 결론:
# - n이 클수록 O(n log n)이 압도적으로 빠름
# - O(n²)는 n=10,000 이상에서는 실용적이지 않음
# - 대용량 데이터는 반드시 O(n log n) 이하 필요
#
# 정답: 병합 정렬이 약 385배 빠름]]></solution>
  </problem>

  <!-- 문제 9: 코드 비교 (제자리 vs 추가 공간) -->
  <problem>
    <description>제자리 정렬(In-place Sort)의 개념을 설명하고, 병합 정렬과 퀵 정렬 중 어느 것이 제자리 정렬인지 이유와 함께 답하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 제자리 정렬(In-place Sort) 개념
#
# 정의:
# - 입력 배열 외에 추가 메모리를 거의 사용하지 않는 정렬
# - O(1) 또는 O(log n) 정도의 추가 공간만 사용
# - 원본 배열 내에서 직접 정렬
#
# 장점:
# - 메모리 효율적
# - 공간복잡도 낮음
# - 대용량 데이터에 유리
#
# 단점:
# - 구현이 복잡할 수 있음
# - 원본 배열이 변경됨
#
# 병합 정렬 vs 퀵 정렬:
#
# 1. 병합 정렬: 제자리 정렬 아님 ✗
#    def merge_sort(A):
#        if len(A) <= 1:
#            return A
#        m = len(A) // 2
#        L = merge_sort(A[:m])     # 새 배열 L
#        R = merge_sort(A[m:])     # 새 배열 R
#        return merge(L, R)        # 새 배열 반환
#
#    def merge(L, R):
#        res = []                  # 새 배열 res
#        # L과 R을 병합하여 res에 저장
#        return res
#
#    - 분할 시 새 배열 생성 (L, R)
#    - 병합 시 새 배열 생성 (res)
#    - 공간복잡도: O(n)
#    - n개 원소에 대해 n만큼 추가 메모리 필요
#
#    예: n=8
#    [8개] → [4개] + [4개] (8개 공간)
#          → [2+2] + [2+2] (8개 공간)
#          → [1+1+1+1+1+1+1+1] (8개 공간)
#
# 2. 퀵 정렬: 제자리 정렬 ✓ (일반적 구현)
#    def quick_sort(A, lo, hi):
#        if lo < hi:
#            p = partition(A, lo, hi)  # 제자리 분할
#            quick_sort(A, lo, p-1)
#            quick_sort(A, p+1, hi)
#
#    def partition(A, lo, hi):
#        pivot = A[hi]
#        i = lo - 1
#        for j in range(lo, hi):
#            if A[j] < pivot:
#                i += 1
#                A[i], A[j] = A[j], A[i]  # 제자리 교환
#        A[i+1], A[hi] = A[hi], A[i+1]
#        return i + 1
#
#    - 원본 배열 내에서 직접 교환
#    - 추가 배열 생성 안함
#    - 공간복잡도: O(log n) (재귀 스택만)
#
# 예외:
# - Python의 list comprehension 버전 퀵 정렬은
#   제자리 정렬이 아님:
#   L = [x for x in A if x < p]  # 새 배열
#   R = [x for x in A if x > p]  # 새 배열
#
# 정리:
# - 선택 정렬: 제자리 ✓ (O(1))
# - 버블 정렬: 제자리 ✓ (O(1))
# - 삽입 정렬: 제자리 ✓ (O(1))
# - 병합 정렬: 제자리 ✗ (O(n))
# - 퀵 정렬: 제자리 ✓ (O(log n), 일반 구현)
#
# 정답: 퀵 정렬이 제자리 정렬
# (일반적인 partition 기반 구현)]]></solution>
  </problem>

  <!-- 문제 10: 디버깅 (정렬 알고리즘 오류) -->
  <problem>
    <description>다음 삽입 정렬 코드에 오류가 있습니다. 오류를 찾아 고치세요.</description>
    <code><![CDATA[def f(A):
    n = len(A)
    for i in range(1, n):
        k = A[i]
        j = i - 1
        while j > 0 and A[j] > k:
            A[j+1] = A[j]
            j -= 1
        A[j+1] = k]]></code>
    <input><![CDATA[A = [5, 2, 4, 1, 3]
f(A)
print(A)]]></input>
    <output><![CDATA[[1, 2, 3, 4, 5]]]></output>
    <solution><![CDATA[def f(A):
    n = len(A)
    for i in range(1, n):
        k = A[i]
        j = i - 1
        while j >= 0 and A[j] > k:  # 오류: j > 0이 아니라 j >= 0
            A[j+1] = A[j]
            j -= 1
        A[j+1] = k

# 잘못된 부분: while j > 0
#
# 오류 이유:
# - j > 0은 j가 1 이상일 때만 반복
# - j=0인 경우를 확인하지 않음
# - A[0]이 k보다 크면 교환되지 않음
#
# 구체적 예시:
# A = [5, 2, 4, 1, 3]
# i=1, k=2:
#   j=0, A[0]=5 > 2이지만 j > 0이 거짓
#   → while 진입 안함
#   → A[1] = 2 (교환 안됨)
#   → 결과: [5, 2, 4, 1, 3] (오류!)
#
# 올바른 조건: j >= 0
# - j가 0일 때도 확인
# - A[0]까지 비교 가능
#
# 수정 후 실행:
# A = [5, 2, 4, 1, 3]
# i=1, k=2:
#   j=0, A[0]=5 > 2 → 이동
#   j=-1 → 종료
#   → A[0] = 2
#   → 결과: [2, 5, 4, 1, 3]
#
# i=2, k=4:
#   → [2, 4, 5, 1, 3]
# i=3, k=1:
#   → [1, 2, 4, 5, 3]
# i=4, k=3:
#   → [1, 2, 3, 4, 5]
#
# 정답: while j >= 0 and A[j] > k]]></solution>
  </problem>

  <!-- 문제 11: 조건 역추론 (최선=최악인 정렬) -->
  <problem>
    <description>최선의 경우와 최악의 경우 시간복잡도가 같은 정렬 알고리즘을 2개 쓰고, 그 이유를 간단히 설명하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 최선 = 최악인 정렬 알고리즘
#
# 1. 선택 정렬 (Selection Sort)
#    - 최선 = 최악 = O(n²)
#    - 이유: 항상 남은 모든 원소를 비교해야 함
#            이미 정렬되어 있어도 최솟값을 찾기 위해
#            모든 원소 확인
#
#    for i in range(n-1):
#        m = i
#        for j in range(i+1, n):  # 항상 n-i-1번
#            if A[j] < A[m]:
#                m = j
#        swap(A[i], A[m])
#
#    비교 횟수: (n-1) + (n-2) + ... + 1 = n(n-1)/2
#    항상 같음!
#
# 2. 병합 정렬 (Merge Sort)
#    - 최선 = 최악 = O(n log n)
#    - 이유: 항상 배열을 절반씩 나누고
#            모든 원소를 병합
#            입력 상태와 무관하게 같은 구조
#
#    def merge_sort(A):
#        if len(A) <= 1:
#            return A
#        m = len(A) // 2
#        L = merge_sort(A[:m])     # 항상 절반
#        R = merge_sort(A[m:])     # 항상 절반
#        return merge(L, R)        # 항상 n번 병합
#
#    분할 깊이: log n (항상 같음)
#    각 단계 병합: n (항상 같음)
#
# 비교:
# - 삽입 정렬: 최선 O(n) ≠ 최악 O(n²)
# - 버블 정렬: 최선 O(n) ≠ 최악 O(n²) (최적화 시)
# - 퀵 정렬: 평균 O(n log n) ≠ 최악 O(n²)
#
# 특징:
# - 예측 가능한 성능
# - 실시간 시스템에 적합
# - 최악의 경우에도 보장된 성능
#
# 정답:
# 1. 선택 정렬 (O(n²))
# 2. 병합 정렬 (O(n log n))]]></solution>
  </problem>

  <!-- 문제 12: 서술형 (정렬 선택 기준) -->
  <problem>
    <description>다음 상황에서 어떤 정렬 알고리즘을 선택할지 이유와 함께 답하세요: (1) 거의 정렬된 1000개 데이터, (2) 완전 랜덤 100만개 데이터, (3) 메모리가 극도로 제한된 환경</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 상황별 정렬 알고리즘 선택
#
# (1) 거의 정렬된 1000개 데이터
#
# 선택: 삽입 정렬 (Insertion Sort)
#
# 이유:
# - 최선의 경우: O(n)
# - 거의 정렬된 배열에서 매우 효율적
# - 각 원소가 이미 제자리에 가까움
# - while 루프가 거의 실행 안됨
#
# 예시:
# [1, 2, 3, 5, 4, 6, 7, 8]
# - 4만 한 칸 이동하면 됨
# - O(n)에 가까운 성능
#
# 대안: 팀소트(Timsort) - Python 내장 sort()
# - 삽입 정렬 + 병합 정렬 혼합
# - 거의 정렬된 경우 O(n)
#
# (2) 완전 랜덤 100만개 데이터
#
# 선택: 병합 정렬 (Merge Sort) 또는 퀵 정렬 (Quick Sort)
#
# 이유:
# - O(n log n) 복잡도 필수
# - O(n²)는 너무 느림 (1조 번 연산)
#
# 병합 정렬:
# - 최악에도 O(n log n) 보장
# - 안정 정렬
# - 예측 가능한 성능
# - 단점: O(n) 추가 메모리
#
# 퀵 정렬:
# - 평균 O(n log n)
# - 제자리 정렬 (메모리 효율)
# - 캐시 효율성 좋음
# - 실제로 가장 빠름
# - 단점: 최악 O(n²) (랜덤 피벗으로 회피)
#
# 연산 횟수 비교 (n=1,000,000):
# - O(n²): 1조 번 (1,000,000초 ≈ 11일)
# - O(n log n): 2천만 번 (0.2초)
#
# (3) 메모리가 극도로 제한된 환경
#
# 선택: 힙 정렬 (Heap Sort) 또는 퀵 정렬
#
# 이유:
# - 제자리 정렬 필요
# - O(1) 또는 O(log n) 공간만 사용
#
# 힙 정렬:
# - 최악에도 O(n log n)
# - 공간복잡도: O(1)
# - 제자리 정렬
# - 안정적이지 않음
# - 병합 정렬보다 느리지만 메모리 효율
#
# 퀵 정렬:
# - 평균 O(n log n)
# - 공간복잡도: O(log n) (재귀 스택)
# - 제자리 정렬
# - 실전에서 가장 빠름
#
# 피해야 할 것:
# - 병합 정렬: O(n) 메모리 필요
# - 팀소트: 추가 메모리 사용
#
# 요약:
# (1) 거의 정렬됨 → 삽입 정렬 (O(n))
# (2) 대용량 랜덤 → 병합/퀵 정렬 (O(n log n))
# (3) 메모리 제한 → 힙/퀵 정렬 (제자리 정렬)
#
# 실전 팁:
# - Python: sorted() 또는 list.sort() (팀소트)
# - 작은 배열(<50): 삽입 정렬
# - 큰 배열: 퀵/병합 정렬
# - 안정성 필요: 병합 정렬
# - 메모리 제한: 힙/퀵 정렬]]></solution>
  </problem>
</problems>
