<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: 출력 예측 (1~10 소수 개수) - 워밍업 -->
  <problem>
    <description>다음 코드의 출력 결과를 쓰세요.</description>
    <code><![CDATA[def is_prime(k):
    for i in range(2, int(k**0.5)+1):
        if k % i == 0:
            return False
    return True

cnt = 0
for i in range(2, 11):
    if is_prime(i):
        cnt += 1

print(cnt)]]></code>
    <input></input>
    <output><![CDATA[4]]></output>
    <solution><![CDATA[# 2부터 10까지의 소수: 2, 3, 5, 7
# 개수: 4개
#
# 정답: 4]]></solution>
  </problem>

  <!-- 문제 2: 빈칸 채우기 (카운터 증가) [기존 스타일] -->
  <problem>
    <description>다음 코드는 2부터 n까지의 수 중 소수의 개수를 세는 코드입니다. 빈칸을 채우세요.</description>
    <code><![CDATA[ans = 0
n = 100

for i in range(2, n+1):
    cnt = 0
    for j in range(2, i):
        if ____:
            cnt = cnt + 1

    if cnt == 0:
        ans += 1

print(ans)]]></code>
    <input></input>
    <output><![CDATA[25]]></output>
    <solution><![CDATA[ans = 0
n = 100

for i in range(2, n+1):
    cnt = 0
    for j in range(2, i):
        if (i%j) == 0:  # 정답: (i%j) == 0 또는 i%j == 0
            cnt = cnt + 1

    if cnt == 0:
        ans += 1

print(ans)

# i를 j로 나눈 나머지가 0이면 약수가 존재
# cnt가 0이면 약수가 없으므로 소수]]></solution>
  </problem>

  <!-- 문제 3: 전체 작성 (기본 버전) -->
  <problem>
    <description>2부터 n까지의 수 중 소수의 개수를 세는 함수를 작성하세요.</description>
    <code><![CDATA[def f(n):
    pass]]></code>
    <input><![CDATA[print(f(50))
print(f(20))]]></input>
    <output><![CDATA[15
8]]></output>
    <solution><![CDATA[def f(n):
    ans = 0
    for i in range(2, n+1):
        cnt = 0
        for j in range(2, i):
            if (i%j) == 0:
                cnt = cnt + 1
        if cnt == 0:
            ans += 1
    return ans

# 각 수 i에 대해 2부터 i-1까지 나누어떨어지는지 확인
# 약수가 없으면 (cnt==0) 소수로 카운트]]></solution>
  </problem>

  <!-- 문제 4: 디버깅 (범위 오류) -->
  <problem>
    <description>다음 소수 개수 세기 함수에 오류가 있습니다. 오류를 찾아 고치세요.</description>
    <code><![CDATA[def f(n):
    ans = 0
    for i in range(1, n+1):
        cnt = 0
        for j in range(2, i):
            if (i%j) == 0:
                cnt += 1
        if cnt == 0:
            ans += 1
    return ans]]></code>
    <input><![CDATA[print(f(10))]]></input>
    <output><![CDATA[4]]></output>
    <solution><![CDATA[def f(n):
    ans = 0
    for i in range(2, n+1):  # 오류: range(1, n+1)이 아니라 range(2, n+1)
        cnt = 0
        for j in range(2, i):
            if (i%j) == 0:
                cnt += 1
        if cnt == 0:
            ans += 1
    return ans

# 잘못된 부분: range(1, n+1)
# 이유: 1은 소수가 아님 (소수는 2 이상의 자연수)
# 1부터 시작하면 1도 소수로 카운트됨 (1은 range(2, 1)이 빈 범위라 cnt=0)
# 정답: range(2, n+1)로 2부터 시작]]></solution>
  </problem>

  <!-- 문제 5: 서술형 (에라토스테네스의 체 개념) -->
  <problem>
    <description>에라토스테네스의 체(Sieve of Eratosthenes) 알고리즘의 원리를 서술하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 에라토스테네스의 체 알고리즘
#
# 원리:
# 소수의 배수는 모두 합성수(소수가 아님)라는 성질을 이용
#
# 알고리즘 단계:
# 1. 2부터 n까지 모든 수를 나열
# 2. 2는 소수이므로 표시, 2의 배수(4,6,8,...)를 모두 제거
# 3. 다음 남은 수 3은 소수이므로 표시, 3의 배수(6,9,12,...)를 모두 제거
# 4. 다음 남은 수 5는 소수이므로 표시, 5의 배수(10,15,20,...)를 모두 제거
# 5. √n까지 반복
# 6. 남은 수들이 모두 소수
#
# 예: n=30
# 초기: 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
# 2의 배수 제거: 2 3 5 7 9 11 13 15 17 19 21 23 25 27 29
# 3의 배수 제거: 2 3 5 7 11 13 17 19 23 25 29
# 5의 배수 제거: 2 3 5 7 11 13 17 19 23 29
# 결과: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 (10개)
#
# 시간복잡도: O(n log log n)
# - 직접 판별(O(n√n))보다 효율적]]></solution>
  </problem>

  <!-- 문제 6: 빈칸 채우기 (체 알고리즘) -->
  <problem>
    <description>에라토스테네스의 체 알고리즘입니다. 빈칸을 채우세요.</description>
    <code><![CDATA[def f(n):
    s = [True] * (n+1)
    s[0] = s[1] = False

    for i in range(2, int(n**0.5)+1):
        if s[i]:
            for j in range(____, n+1, i):
                s[j] = False

    return sum(s)]]></code>
    <input><![CDATA[print(f(30))
print(f(50))]]></input>
    <output><![CDATA[10
15]]></output>
    <solution><![CDATA[def f(n):
    s = [True] * (n+1)
    s[0] = s[1] = False

    for i in range(2, int(n**0.5)+1):
        if s[i]:
            for j in range(i*i, n+1, i):  # 정답: i*i
                s[j] = False

    return sum(s)

# i*i부터 시작하는 이유:
# i의 배수 중 i*i보다 작은 것들은 이미 제거됨
# 예: i=5일 때, 5*2=10, 5*3=15, 5*4=20은 이미 2,3,4의 배수로 제거
# 따라서 5*5=25부터 시작하면 됨]]></solution>
  </problem>

  <!-- 문제 7: 코드 비교 (직접 vs 체) -->
  <problem>
    <description>다음 두 소수 개수 세기 방법 중 더 효율적인 것은? 그 이유는?</description>
    <code><![CDATA[# 방법 A: 직접 판별
def f(n):
    ans = 0
    for i in range(2, n+1):
        cnt = 0
        for j in range(2, int(i**0.5)+1):
            if (i%j) == 0:
                cnt += 1
        if cnt == 0:
            ans += 1
    return ans

# 방법 B: 에라토스테네스의 체
def f(n):
    s = [True] * (n+1)
    s[0] = s[1] = False
    for i in range(2, int(n**0.5)+1):
        if s[i]:
            for j in range(i*i, n+1, i):
                s[j] = False
    return sum(s)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 정답: 방법 B (에라토스테네스의 체)가 더 효율적
#
# 방법 A: O(n√n)
# - 각 수마다 √n까지 확인
# - n개의 수 × √n번 확인 = O(n√n)
# - n=1000일 때: 약 31,000번 연산
#
# 방법 B: O(n log log n)
# - 각 소수의 배수만 제거
# - 수학적으로 증명된 시간복잡도
# - n=1000일 때: 약 10,000번 연산
#
# 비교:
# n=100:    방법A ≈ 1,000  vs  방법B ≈ 500
# n=1000:   방법A ≈ 31,000 vs  방법B ≈ 10,000
# n=10000:  방법A ≈ 1,000,000 vs  방법B ≈ 130,000
#
# 결론: n이 클수록 방법 B가 훨씬 빠름
# 특히 n이 매우 클 때 (100만 이상) 큰 차이]]></solution>
  </problem>

  <!-- 문제 8: 조건 역추론 (n번째 소수) -->
  <problem>
    <description>에라토스테네스의 체를 이용하여 n번째 소수를 찾는 함수를 작성하세요. (첫 번째 소수는 2입니다)</description>
    <code><![CDATA[def f(n):
    pass]]></code>
    <input><![CDATA[print(f(10))
print(f(25))]]></input>
    <output><![CDATA[29
97]]></output>
    <solution><![CDATA[def f(n):
    # 충분히 큰 범위로 체 생성
    limit = max(100, n * 15)
    s = [True] * (limit+1)
    s[0] = s[1] = False

    for i in range(2, int(limit**0.5)+1):
        if s[i]:
            for j in range(i*i, limit+1, i):
                s[j] = False

    # n번째 소수 찾기
    cnt = 0
    for i in range(2, limit+1):
        if s[i]:
            cnt += 1
            if cnt == n:
                return i
    return -1

# n번째 소수를 찾기 위해 충분히 큰 범위 설정 필요
# n * 15는 경험적 값 (n번째 소수는 대략 n*ln(n) 근처)
# 10번째 소수: 29
# 25번째 소수: 97]]></solution>
  </problem>

  <!-- 문제 9: 복잡도 분석 (체 알고리즘) -->
  <problem>
    <description>에라토스테네스의 체 알고리즘의 시간복잡도를 분석하고, n=1000000일 때 대략적인 연산 횟수를 구하세요.</description>
    <code><![CDATA[def f(n):
    s = [True] * (n+1)
    s[0] = s[1] = False

    for i in range(2, int(n**0.5)+1):
        if s[i]:
            for j in range(i*i, n+1, i):
                s[j] = False

    return sum(s)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 시간복잡도: O(n log log n)
#
# 분석:
# - 외부 루프: 2부터 √n까지 (√n번)
# - 내부 루프: i가 소수일 때만 실행
#   - 2의 배수: n/2개 제거
#   - 3의 배수: n/3개 제거
#   - 5의 배수: n/5개 제거
#   - ...
# - 총 연산: n × (1/2 + 1/3 + 1/5 + 1/7 + ...)
#   = n × (소수들의 역수 합)
#   ≈ n × log log n (수학적으로 증명됨)
#
# n=1000000일 때:
# - log log 1000000 ≈ log(13.8) ≈ 2.6
# - 연산 횟수: 1000000 × 2.6 ≈ 2,600,000
#
# 비교 (n=1000000):
# - 직접 판별 O(n√n): 1000000 × 1000 = 1,000,000,000 (10억)
# - 체 O(n log log n): 2,600,000 (260만)
# - 약 400배 빠름!
#
# 정답: O(n log log n), 약 260만 번]]></solution>
  </problem>

  <!-- 문제 10: 전체 작성 (구간 내 소수) -->
  <problem>
    <description>a부터 b까지의 범위에서 소수의 개수를 세는 함수를 작성하세요. (a, b 포함)</description>
    <code><![CDATA[def f(a, b):
    pass]]></code>
    <input><![CDATA[print(f(10, 20))
print(f(1, 10))]]></input>
    <output><![CDATA[4
4]]></output>
    <solution><![CDATA[def f(a, b):
    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, int(k**0.5)+1):
            if k % i == 0:
                return False
        return True

    cnt = 0
    for i in range(a, b+1):
        if is_prime(i):
            cnt += 1
    return cnt

# 10~20: 11, 13, 17, 19 → 4개
# 1~10: 2, 3, 5, 7 → 4개
#
# 또는 체를 이용한 방법:
def f(a, b):
    s = [True] * (b+1)
    s[0] = s[1] = False
    for i in range(2, int(b**0.5)+1):
        if s[i]:
            for j in range(i*i, b+1, i):
                s[j] = False
    return sum(s[a:b+1])]]></solution>
  </problem>
</problems>
