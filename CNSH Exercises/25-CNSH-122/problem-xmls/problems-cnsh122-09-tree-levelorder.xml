<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: 출력 예측 (레벨 순서 결과) - 워밍업 -->
  <problem>
    <description>다음 레벨 순서 순회 코드의 출력 결과를 쓰세요.</description>
    <code><![CDATA[T = [1, 2, 3, 4, 5, 6, 7]

def f():
    Q = [0]
    while Q:
        i = Q.pop(0)
        print(T[i], end=' ')
        if 2*i + 1 < len(T):
            Q.append(2*i + 1)
        if 2*i + 2 < len(T):
            Q.append(2*i + 2)

f()]]></code>
    <input></input>
    <output><![CDATA[1 2 3 4 5 6 7]]></output>
    <solution><![CDATA[# 레벨 순서 순회 (Level-order / BFS)
# 트리 구조:
#       1
#      / \
#     2   3
#    / \ / \
#   4  5 6  7
#
# 레벨별 순회:
# Level 0: 1
# Level 1: 2, 3
# Level 2: 4, 5, 6, 7
#
# 큐 동작 과정:
# Q=[0] → 1 출력, Q=[1,2]
# Q=[1,2] → 2 출력, Q=[2,3,4]
# Q=[2,3,4] → 3 출력, Q=[3,4,5,6]
# Q=[3,4,5,6] → 4 출력, Q=[4,5,6]
# Q=[4,5,6] → 5 출력, Q=[5,6]
# Q=[5,6] → 6 출력, Q=[6]
# Q=[6] → 7 출력, Q=[]
#
# 정답: 1 2 3 4 5 6 7]]></solution>
  </problem>

  <!-- 문제 2: 서술형 (BFS vs DFS 차이) -->
  <problem>
    <description>BFS(너비 우선 탐색)와 DFS(깊이 우선 탐색)의 차이점을 자료구조, 순회 순서, 활용 측면에서 설명하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# BFS vs DFS 비교
#
# 1. 자료구조:
# - BFS: 큐(Queue) 사용 - FIFO (선입선출)
# - DFS: 스택(Stack) 사용 - LIFO (후입선출)
#   또는 재귀 함수 (암묵적 스택)
#
# 2. 순회 순서:
# - BFS: 레벨별로 순회 (가까운 노드부터)
#   예: 1 → 2, 3 → 4, 5, 6, 7
# - DFS: 깊이 방향으로 순회 (끝까지 간 후 백트래킹)
#   예: 1 → 2 → 4 → 5 → 3 → 6 → 7 (전위)
#
# 3. 시간복잡도:
# - BFS: O(n)
# - DFS: O(n)
# (둘 다 모든 노드 방문)
#
# 4. 공간복잡도:
# - BFS: O(w), w는 최대 너비 (한 레벨의 최대 노드 수)
#   완전 이진 트리: O(n/2) = O(n)
# - DFS: O(h), h는 트리 높이
#   완전 이진 트리: O(log n)
#
# 5. 활용:
# - BFS: 최단 경로 찾기, 레벨별 처리
#   예: 게임 AI, 소셜 네트워크 분석
# - DFS: 경로 존재 여부, 위상 정렬
#   예: 미로 찾기, 사이클 검출
#
# 6. 장단점:
# - BFS:
#   장점: 최단 경로 보장
#   단점: 메모리 많이 사용 (넓은 트리)
# - DFS:
#   장점: 메모리 적게 사용 (깊은 트리)
#   단점: 최단 경로 보장 안 됨
#
# 예시 트리에서의 순회:
#       A
#      / \
#     B   C
#    / \
#   D   E
#
# BFS: A B C D E (레벨 순서)
# DFS(전위): A B D E C (깊이 우선)]]></solution>
  </problem>

  <!-- 문제 3: 출력 예측 (배열 표현 = 레벨 순서) -->
  <problem>
    <description>배열로 표현된 완전 이진 트리는 그 자체로 레벨 순서와 동일합니다. 다음 트리의 레벨 순서 순회 결과를 쓰세요.</description>
    <code><![CDATA[T = [10, 20, 30, 40, 50]]]></code>
    <input></input>
    <output><![CDATA[10 20 30 40 50]]></output>
    <solution><![CDATA[# 배열 표현과 레벨 순서의 관계
#
# 트리 구조:
#       10
#      /  \
#     20   30
#    / \
#   40 50
#
# 배열로 저장할 때:
# 인덱스: 0   1   2   3   4
# 값:    10  20  30  40  50
#
# 레벨별 저장:
# Level 0: 10 (인덱스 0)
# Level 1: 20, 30 (인덱스 1-2)
# Level 2: 40, 50 (인덱스 3-4)
#
# 특징:
# - 완전 이진 트리를 배열로 표현하면
#   배열 순서 = 레벨 순서 순회 결과
# - 따라서 레벨 순서 출력 = 배열을 순서대로 출력
#
# 정답: 10 20 30 40 50
#
# 참고:
# - 이것이 힙(Heap)이 배열로 구현되는 이유
# - 부모-자식 관계를 인덱스로 쉽게 계산 가능]]></solution>
  </problem>

  <!-- 문제 4: 빈칸 채우기 (큐 연산) -->
  <problem>
    <description>레벨 순서 순회를 구현하는 코드입니다. 빈칸을 채우세요.</description>
    <code><![CDATA[T = [5, 3, 8, 1, 4, 6, 9]

def f():
    Q = [0]
    while Q:
        i = ____
        print(T[i], end=' ')
        if 2*i + 1 < len(T):
            Q.append(2*i + 1)
        if 2*i + 2 < len(T):
            Q.append(2*i + 2)]]></code>
    <input><![CDATA[f()]]></input>
    <output><![CDATA[5 3 8 1 4 6 9]]></output>
    <solution><![CDATA[T = [5, 3, 8, 1, 4, 6, 9]

def f():
    Q = [0]
    while Q:
        i = Q.pop(0)  # 정답: Q.pop(0)
        print(T[i], end=' ')
        if 2*i + 1 < len(T):
            Q.append(2*i + 1)
        if 2*i + 2 < len(T):
            Q.append(2*i + 2)

# 큐(Queue) 연산:
# - Q.pop(0): 맨 앞 요소 제거 및 반환 (dequeue)
# - Q.append(x): 맨 뒤에 요소 추가 (enqueue)
#
# FIFO (First In First Out):
# - 먼저 들어간 것이 먼저 나옴
# - BFS의 핵심 원리
#
# 동작 과정:
# Q=[0] → pop(0)=0, Q=[1,2]
# Q=[1,2] → pop(0)=1, Q=[2,3,4]
# Q=[2,3,4] → pop(0)=2, Q=[3,4,5,6]
# ...
#
# 트리 구조:
#       5
#      / \
#     3   8
#    / \ / \
#   1  4 6  9
#
# 출력: 5 3 8 1 4 6 9]]></solution>
  </problem>

  <!-- 문제 5: 디버깅 (큐 순서 오류) -->
  <problem>
    <description>다음 레벨 순서 순회 코드에 오류가 있습니다. 오류를 찾아 고치세요.</description>
    <code><![CDATA[T = [1, 2, 3, 4, 5, 6, 7]

def f():
    Q = [0]
    while Q:
        i = Q.pop()
        print(T[i], end=' ')
        if 2*i + 1 < len(T):
            Q.append(2*i + 1)
        if 2*i + 2 < len(T):
            Q.append(2*i + 2)]]></code>
    <input><![CDATA[f()]]></input>
    <output><![CDATA[1 2 3 4 5 6 7]]></output>
    <solution><![CDATA[T = [1, 2, 3, 4, 5, 6, 7]

def f():
    Q = [0]
    while Q:
        i = Q.pop(0)  # 오류 수정: pop() → pop(0)
        print(T[i], end=' ')
        if 2*i + 1 < len(T):
            Q.append(2*i + 1)
        if 2*i + 2 < len(T):
            Q.append(2*i + 2)

# 오류: Q.pop() 사용
# - pop(): 맨 뒤 요소 제거 (스택, LIFO)
# - pop(0): 맨 앞 요소 제거 (큐, FIFO)
#
# 잘못된 동작 (pop() 사용 시):
# Q=[0] → pop()=0, Q=[1,2]
# Q=[1,2] → pop()=2, Q=[1,3,4] (2를 먼저 처리)
# Q=[1,3,4] → pop()=4, Q=[1,3] (DFS처럼 동작)
# → 출력: 1 3 7 6 2 5 4 (깊이 우선)
#
# 올바른 동작 (pop(0) 사용 시):
# Q=[0] → pop(0)=0, Q=[1,2]
# Q=[1,2] → pop(0)=1, Q=[2,3,4] (1을 먼저 처리)
# Q=[2,3,4] → pop(0)=2, Q=[3,4,5,6] (BFS)
# → 출력: 1 2 3 4 5 6 7 (레벨 순서)
#
# 결론: BFS는 반드시 pop(0) 사용 (큐)]]></solution>
  </problem>

  <!-- 문제 6: 전체 작성 (레벨 순서 순회) -->
  <problem>
    <description>배열로 표현된 이진 트리를 레벨 순서로 순회하는 함수를 작성하세요. 각 노드의 값을 공백으로 구분하여 출력하세요.</description>
    <code><![CDATA[T = [15, 10, 20, 5, 12, 18, 25]

def f():
    pass]]></code>
    <input><![CDATA[f()]]></input>
    <output><![CDATA[15 10 20 5 12 18 25]]></output>
    <solution><![CDATA[T = [15, 10, 20, 5, 12, 18, 25]

def f():
    Q = [0]
    while Q:
        i = Q.pop(0)
        print(T[i], end=' ')
        if 2*i + 1 < len(T):
            Q.append(2*i + 1)
        if 2*i + 2 < len(T):
            Q.append(2*i + 2)

# 레벨 순서 순회 (BFS) 구현
#
# 알고리즘:
# 1. 큐에 루트 인덱스(0) 추가
# 2. 큐가 빌 때까지 반복:
#    a. 큐에서 인덱스 꺼내기 (pop(0))
#    b. 해당 노드 방문 (출력)
#    c. 왼쪽 자식이 있으면 큐에 추가
#    d. 오른쪽 자식이 있으면 큐에 추가
#
# 트리 구조:
#        15
#       /  \
#      10   20
#     / \   / \
#    5  12 18 25
#
# 레벨별 출력:
# Level 0: 15
# Level 1: 10, 20
# Level 2: 5, 12, 18, 25]]></solution>
  </problem>

  <!-- 문제 7: 블록 채우기 (레벨별 출력) -->
  <problem>
    <description>다음 코드는 각 레벨을 구분하여 출력합니다. 빈칸을 채우세요.</description>
    <code><![CDATA[T = [1, 2, 3, 4, 5, 6, 7]

def f():
    Q = [(0, 0)]
    lv = 0
    while Q:
        i, d = Q.pop(0)
        if d > lv:
            print()
            lv = ____
        print(T[i], end=' ')
        if 2*i + 1 < len(T):
            Q.append((2*i + 1, ____))
        if 2*i + 2 < len(T):
            Q.append((2*i + 2, ____))]]></code>
    <input><![CDATA[f()]]></input>
    <output><![CDATA[1
2 3
4 5 6 7]]></output>
    <solution><![CDATA[T = [1, 2, 3, 4, 5, 6, 7]

def f():
    Q = [(0, 0)]
    lv = 0
    while Q:
        i, d = Q.pop(0)
        if d > lv:
            print()
            lv = d  # 정답: d
        print(T[i], end=' ')
        if 2*i + 1 < len(T):
            Q.append((2*i + 1, d + 1))  # 정답: d + 1
        if 2*i + 2 < len(T):
            Q.append((2*i + 2, d + 1))  # 정답: d + 1

# 레벨별 출력 구현
#
# 아이디어:
# - 각 노드와 함께 깊이(depth) 정보를 큐에 저장
# - 깊이가 바뀔 때마다 줄바꿈
#
# 동작 과정:
# Q=[(0,0)] → 1 출력, Q=[(1,1),(2,1)]
# Q=[(1,1),(2,1)] → 줄바꿈, 2 출력, Q=[(2,1),(3,2),(4,2)]
# Q=[(2,1),(3,2),(4,2)] → 3 출력, Q=[(3,2),(4,2),(5,2),(6,2)]
# Q=[(3,2),(4,2),(5,2),(6,2)] → 줄바꿈, 4 출력...
#
# 출력 형태:
# 1 (Level 0)
# 2 3 (Level 1)
# 4 5 6 7 (Level 2)
#
# 튜플 구조: (인덱스, 깊이)
# - i: 노드 인덱스
# - d: 현재 깊이 (레벨)
# - 자식의 깊이는 부모 깊이 + 1]]></solution>
  </problem>

  <!-- 문제 8: 코드 비교 (DFS vs BFS) -->
  <problem>
    <description>다음 두 코드의 차이점을 설명하고, 각각의 출력 결과를 쓰세요.</description>
    <code><![CDATA[T = [1, 2, 3, 4, 5]

# 코드 A
def a(i):
    if i >= len(T):
        return
    print(T[i], end=' ')
    a(2*i + 1)
    a(2*i + 2)

# 코드 B
def b():
    Q = [0]
    while Q:
        i = Q.pop(0)
        print(T[i], end=' ')
        if 2*i + 1 < len(T):
            Q.append(2*i + 1)
        if 2*i + 2 < len(T):
            Q.append(2*i + 2)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 코드 A: DFS (깊이 우선 탐색) - 전위 순회
# 출력: 1 2 4 5 3
#
# 코드 B: BFS (너비 우선 탐색) - 레벨 순서 순회
# 출력: 1 2 3 4 5
#
# 트리 구조:
#     1
#    / \
#   2   3
#  / \
# 4   5
#
# 차이점:
#
# 1. 구현 방식:
# - A: 재귀 함수 (암묵적 스택)
# - B: 반복문 + 큐 (명시적 큐)
#
# 2. 순회 순서:
# - A: 1 → 2 → 4 → 5 → 3 (깊이 방향)
# - B: 1 → 2 → 3 → 4 → 5 (레벨별)
#
# 3. 자료구조:
# - A: 스택 (LIFO) - 재귀 호출 스택
# - B: 큐 (FIFO) - 명시적 큐
#
# 4. 방문 패턴:
# - A: 한 방향으로 끝까지 간 후 백트래킹
# - B: 같은 레벨의 노드들을 먼저 방문
#
# 5. 메모리 사용:
# - A: O(h), h는 트리 높이
# - B: O(w), w는 최대 너비
#
# 6. 활용:
# - A: 경로 탐색, 위상 정렬
# - B: 최단 경로, 레벨별 처리
#
# 예시 실행:
# a(0) 호출: 1 2 4 5 3
# b() 호출: 1 2 3 4 5]]></solution>
  </problem>

  <!-- 문제 9: 복잡도 분석 -->
  <problem>
    <description>레벨 순서 순회(BFS)의 시간복잡도와 공간복잡도를 분석하고, 완전 이진 트리와 편향 트리에서의 차이를 설명하세요.</description>
    <code><![CDATA[def f():
    Q = [0]
    while Q:
        i = Q.pop(0)
        print(T[i], end=' ')
        if 2*i + 1 < len(T):
            Q.append(2*i + 1)
        if 2*i + 2 < len(T):
            Q.append(2*i + 2)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# BFS (레벨 순서 순회) 복잡도 분석
#
# 시간복잡도: O(n)
# - 각 노드를 정확히 1번씩 방문
# - n개 노드 → n번 큐 삽입 + n번 큐 삭제
# - 총 연산: O(n)
#
# 공간복잡도: O(w)
# - w = 트리의 최대 너비 (한 레벨의 최대 노드 수)
# - 큐에 한 레벨의 노드들이 동시에 저장됨
#
# 완전 이진 트리 (높이 h):
# - 노드 수: n ≈ 2^h
# - 최대 너비: 마지막 레벨 = 2^(h-1) ≈ n/2
# - 공간복잡도: O(n/2) = O(n)
#
# 예: n=15 (높이 3)
#           1
#        /     \
#       2       3
#      / \     / \
#     4   5   6   7
#    /|\ /|\ /|\ /|\
#   8 9 ...     15
# 최대 너비: 레벨 3에서 8개 = 15/2
#
# 편향 트리 (한쪽으로만 자식):
# - 노드 수: n
# - 최대 너비: 1 (각 레벨에 1개씩)
# - 공간복잡도: O(1)
#
# 예: n=5
#   1
#    \
#     2
#      \
#       3
#        \
#         4
#          \
#           5
# 최대 너비: 1
#
# DFS와 비교:
# - DFS 공간: O(h)
#   완전: O(log n), 편향: O(n)
# - BFS 공간: O(w)
#   완전: O(n), 편향: O(1)
#
# 결론:
# - 완전 이진 트리: DFS가 공간 효율적 (O(log n) < O(n))
# - 편향 트리: BFS가 공간 효율적 (O(1) < O(n))
#
# 실무 팁:
# - 일반적으로 DFS를 선호 (재귀 구현이 간단)
# - 최단 경로가 필요하면 BFS 필수
# - 넓은 트리(소셜 네트워크)는 DFS 권장
# - 깊은 트리(파일 시스템)는 BFS 권장]]></solution>
  </problem>
</problems>
