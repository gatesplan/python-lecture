<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: 출력 예측 (탐욕법 결과) - 워밍업 -->
  <problem>
    <description>다음 코드의 출력 결과를 쓰세요.</description>
    <code><![CDATA[ans = 0
C = [500, 100, 50, 10]
n = 1780

for c in C:
    ans = ans + n // c
    n = n % c

print(ans)]]></code>
    <input></input>
    <output><![CDATA[9]]></output>
    <solution><![CDATA[# 계산 과정:
# 1780 ÷ 500 = 3개, 나머지 280
#  280 ÷ 100 = 2개, 나머지 80
#   80 ÷ 50  = 1개, 나머지 30
#   30 ÷ 10  = 3개, 나머지 0
#
# 총 3 + 2 + 1 + 3 = 9개
#
# 정답: 9]]></solution>
  </problem>

  <!-- 문제 2: 서술형 (백트래킹 vs 탐욕법) -->
  <problem>
    <description>동전 거스름돈 문제에서 백트래킹과 탐욕법의 차이점을 설명하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 백트래킹(Backtracking):
# - 원리: 모든 경우의 수를 탐색하되, 가지치기로 불필요한 경로 제거
# - 장점: 항상 최적해를 보장
# - 단점: 시간복잡도가 높음 O(k^(n/m))
# - 방법: 각 동전을 하나씩 추가하며 모든 조합 시도
# - 가지치기:
#   1. won > n이면 중단
#   2. d >= ans이면 중단 (이미 찾은 최소값보다 크면)
#
# 탐욕법(Greedy Algorithm):
# - 원리: 매 순간 최선의 선택 (큰 동전부터 최대한 사용)
# - 장점: 매우 빠름 O(k) (k: 동전 종류 개수)
# - 단점: 항상 최적해를 보장하지 않음
# - 방법: 큰 동전부터 순서대로 최대한 많이 사용
# - 최적해 조건: 동전이 배수 관계일 때만 보장
#
# 비교 (n=1780, C=[500,100,50,10]):
# - 백트래킹: 모든 조합 탐색 → 수백만 번 호출 → 수 초
# - 탐욕법: 4번 나눗셈 연산 → 즉시 완료
#
# 사용 시나리오:
# - 백트래킹: 동전이 배수 관계가 아닐 때
#   예: C=[500,400,100]에서 800원 → 탐욕법은 4개, 최적해는 2개
# - 탐욕법: 동전이 배수 관계일 때 (한국 원화, 미국 달러 등)
#
# 결론: 탐욕법이 빠르지만, 최적해 보장이 필요하면 백트래킹 사용]]></solution>
  </problem>

  <!-- 문제 3: 빈칸 채우기 (백트래킹 가지치기) -->
  <problem>
    <description>다음 백트래킹 동전 거스름돈 코드입니다. 빈칸을 채우세요.</description>
    <code><![CDATA[ans = 1e9
C = [500, 100, 50, 10]
n = 1780

def f(w, d):
    global ans
    if w == n:
        ans = min(ans, d)
        return
    if w > n:
        return
    if ____:
        return
    for t in C:
        f(w + t, d + 1)

f(0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[9]]></output>
    <solution><![CDATA[ans = 1e9
C = [500, 100, 50, 10]
n = 1780

def f(w, d):
    global ans
    if w == n:
        ans = min(ans, d)
        return
    if w > n:
        return
    if d >= ans:  # 정답: d >= ans
        return
    for t in C:
        f(w + t, d + 1)

f(0, 0)
print(ans)

# 가지치기 조건: d >= ans
# 이유: 지금까지 사용한 동전 개수가
#       이미 찾은 최소값 이상이면
#       더 탐색해도 최소값을 갱신할 수 없음
# 이 조건으로 탐색 공간을 크게 줄임]]></solution>
  </problem>

  <!-- 문제 4: 디버깅 (탐욕법 순서 오류) -->
  <problem>
    <description>다음 탐욕법 동전 거스름돈 코드에 오류가 있습니다. 오류를 찾아 고치세요.</description>
    <code><![CDATA[ans = 0
C = [10, 50, 100, 500]
n = 1780

for c in C:
    ans = ans + n // c
    n = n % c

print(ans)]]></code>
    <input></input>
    <output><![CDATA[9]]></output>
    <solution><![CDATA[ans = 0
C = [500, 100, 50, 10]  # 오류: 큰 것부터 정렬
n = 1780

for c in C:
    ans = ans + n // c
    n = n % c

print(ans)

# 잘못된 부분: C = [10, 50, 100, 500]
# 이유: 탐욕법은 큰 동전부터 사용해야 최적해
#       작은 동전부터 사용하면 잘못된 결과
#
# 예: 1780원
# 잘못된 순서 [10, 50, 100, 500]:
# 1780 ÷ 10 = 178개, 나머지 0 → 178개 (잘못!)
#
# 올바른 순서 [500, 100, 50, 10]:
# 1780 ÷ 500 = 3개, 나머지 280
#  280 ÷ 100 = 2개, 나머지 80
#   80 ÷ 50  = 1개, 나머지 30
#   30 ÷ 10  = 3개, 나머지 0 → 9개 (정답!)
#
# 정답: C = [500, 100, 50, 10]로 내림차순 정렬]]></solution>
  </problem>

  <!-- 문제 5: 전체 작성 (백트래킹) -->
  <problem>
    <description>주어진 동전 리스트로 정확히 n원을 만들 때 사용하는 동전의 최소 개수를 구하는 백트래킹 함수를 작성하세요.</description>
    <code><![CDATA[def g(C, n):
    pass]]></code>
    <input><![CDATA[print(g([500, 100, 50, 10], 1780))
print(g([500, 100, 50, 10], 370))]]></input>
    <output><![CDATA[9
6]]></output>
    <solution><![CDATA[def g(C, n):
    ans = [1e9]

    def f(w, d):
        if w == n:
            ans[0] = min(ans[0], d)
            return
        if w > n:
            return
        if d >= ans[0]:
            return
        for t in C:
            f(w + t, d + 1)

    f(0, 0)
    return int(ans[0])

# 1780원: 500×3 + 100×2 + 50×1 + 10×3 = 9개
# 370원: 100×3 + 50×1 + 10×2 = 6개
#
# 백트래킹 핵심:
# 1. 모든 동전 조합 시도
# 2. w == n이면 최소값 갱신
# 3. w > n이면 가지치기
# 4. d >= ans이면 가지치기]]></solution>
  </problem>

  <!-- 문제 6: 전체 작성 (탐욕법) -->
  <problem>
    <description>주어진 동전 리스트로 정확히 n원을 만들 때 사용하는 동전의 최소 개수를 구하는 탐욕법 함수를 작성하세요. (동전은 이미 내림차순으로 정렬되어 있다고 가정)</description>
    <code><![CDATA[def g(C, n):
    pass]]></code>
    <input><![CDATA[print(g([500, 100, 50, 10], 1780))
print(g([500, 100, 50, 10], 370))]]></input>
    <output><![CDATA[9
6]]></output>
    <solution><![CDATA[def g(C, n):
    ans = 0
    for c in C:
        ans = ans + n // c
        n = n % c
    return ans

# 탐욕법 핵심:
# 1. 큰 동전부터 최대한 사용
# 2. n // c: 해당 동전으로 사용할 개수
# 3. n % c: 나머지 금액을 다음 동전으로 처리
#
# 1780원:
# 1780 ÷ 500 = 3개, 나머지 280
#  280 ÷ 100 = 2개, 나머지 80
#   80 ÷ 50  = 1개, 나머지 30
#   30 ÷ 10  = 3개, 나머지 0
# 총 9개
#
# 370원:
#  370 ÷ 500 = 0개, 나머지 370
#  370 ÷ 100 = 3개, 나머지 70
#   70 ÷ 50  = 1개, 나머지 20
#   20 ÷ 10  = 2개, 나머지 0
# 총 6개]]></solution>
  </problem>

  <!-- 문제 7: 코드 비교 (백트래킹 vs 탐욕법) -->
  <problem>
    <description>다음 두 동전 거스름돈 방법의 시간복잡도를 비교하고, n=10000, C=[500,100,50,10]일 때 실행 시간 차이를 설명하세요.</description>
    <code><![CDATA[# 방법 A: 백트래킹
ans = 1e9
def f(w, d):
    global ans
    if w == n:
        ans = min(ans, d)
        return
    if w > n or d >= ans:
        return
    for t in C:
        f(w + t, d + 1)

# 방법 B: 탐욕법
ans = 0
for c in C:
    ans = ans + n // c
    n = n % c]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 방법 A (백트래킹):
# - 시간복잡도: O(k^(n/m))
#   k: 동전 종류 개수 (4개)
#   n: 목표 금액 (10000)
#   m: 최소 동전 단위 (10)
# - 최악의 경우: 4^(10000/10) = 4^1000 (천문학적)
# - 가지치기로 줄어들지만 여전히 매우 느림
# - n=10000일 때: 수백만~수억 번 호출 → 수십 초~분
#
# 방법 B (탐욕법):
# - 시간복잡도: O(k) = O(4) = O(1)
# - 동전 종류만큼만 반복 (4번)
# - n=10000일 때: 4번 나눗셈 → 즉시 완료 (밀리초 미만)
#
# 실행 시간 비교 (n=10000):
# - 백트래킹: 10초~60초 (가지치기 정도에 따라)
# - 탐욕법: 0.001초 미만
# - 차이: 약 10000배~60000배
#
# n에 따른 차이:
# - n=1000: 백트래킹 1초 vs 탐욕법 즉시
# - n=5000: 백트래킹 5초 vs 탐욕법 즉시
# - n=10000: 백트래킹 20초 vs 탐욕법 즉시
# - n=50000: 백트래킹 수 분 vs 탐욕법 즉시
#
# 결론:
# - 탐욕법이 압도적으로 빠름
# - 단, 동전이 배수 관계일 때만 최적해 보장
# - 배수 관계가 아니면 백트래킹 필수]]></solution>
  </problem>

  <!-- 문제 8: 서술형 (탐욕법 최적해 조건) -->
  <problem>
    <description>동전 거스름돈 문제에서 탐욕법이 최적해를 보장하는 조건을 설명하고, 그 이유를 서술하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 탐욕법 최적해 조건:
# 동전의 단위가 배수 관계일 때
#
# 배수 관계란:
# - 큰 동전이 작은 동전의 배수인 관계
# - 예: [500, 100, 50, 10]
#   - 500 = 100 × 5
#   - 100 = 50 × 2
#   - 50 = 10 × 5
#   (완벽한 배수는 아니지만 탐욕법이 작동하는 특별한 경우)
#
# 더 정확한 조건:
# - 각 동전 c[i]가 작은 동전들의 조합으로 최적하게 표현 가능
# - c[i] = a₁×c[i+1] + a₂×c[i+2] + ... 형태
#
# 최적해가 보장되는 이유:
# 1. 큰 동전을 사용하는 것이 항상 이득
#    - 큰 동전 1개 = 작은 동전 여러 개
#    - 예: 500원 1개 = 100원 5개
# 2. 큰 동전을 최대한 사용해도 나머지를 최적하게 처리 가능
#    - 배수 관계로 인해 부분 문제도 최적해 유지
#
# 반례 (배수 관계 아님):
# C = [500, 400, 100]에서 800원
# - 탐욕법: 500×1 + 100×3 = 4개
# - 최적해: 400×2 = 2개
# - 이유: 500을 먼저 사용하면 나머지 300을 100으로만 처리
#         하지만 400×2가 더 효율적
#
# 한국 원화 [50000, 10000, 5000, 1000, 500, 100, 50, 10]:
# - 배수 관계는 아니지만 탐욕법이 작동
# - 각 단위가 적절히 설계됨
#
# 결론:
# - 동전이 배수 관계 또는 특별히 설계된 경우 탐욕법 사용 가능
# - 일반적인 경우는 백트래킹으로 검증 필요]]></solution>
  </problem>

  <!-- 문제 9: 조건 역추론 (탐욕법이 실패하는 경우) -->
  <problem>
    <description>동전 리스트 C = [25, 10, 4, 1]에서 탐욕법과 백트래킹의 결과가 다른 금액을 찾고, 그 이유를 설명하세요.</description>
    <code><![CDATA[def greedy(C, n):
    ans = 0
    for c in C:
        ans = ans + n // c
        n = n % c
    return ans

def backtrack(C, n):
    ans = [1e9]
    def f(w, d):
        if w == n:
            ans[0] = min(ans[0], d)
            return
        if w > n or d >= ans[0]:
            return
        for t in C:
            f(w + t, d + 1)
    f(0, 0)
    return int(ans[0])]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 탐욕법과 백트래킹이 다른 결과를 내는 금액: 41원
#
# C = [25, 10, 4, 1]에서 41원:
#
# 탐욕법:
# 41 ÷ 25 = 1개, 나머지 16
# 16 ÷ 10 = 1개, 나머지 6
#  6 ÷ 4  = 1개, 나머지 2
#  2 ÷ 1  = 2개, 나머지 0
# 총 1+1+1+2 = 5개
#
# 백트래킹 (최적해):
# 25×1 + 4×4 = 25+16 = 41
# 총 1+4 = 5개 (탐욕법과 동일)
#
# 더 나은 예: 30원
#
# 탐욕법:
# 30 ÷ 25 = 1개, 나머지 5
#  5 ÷ 10 = 0개, 나머지 5
#  5 ÷ 4  = 1개, 나머지 1
#  1 ÷ 1  = 1개, 나머지 0
# 총 1+0+1+1 = 3개
#
# 백트래킹 (최적해):
# 10×3 = 30
# 총 3개 (동일)
#
# 실제 반례: 41원은 동일, 하지만 31원:
#
# 탐욕법 (31원):
# 31 ÷ 25 = 1개, 나머지 6
#  6 ÷ 10 = 0개, 나머지 6
#  6 ÷ 4  = 1개, 나머지 2
#  2 ÷ 1  = 2개, 나머지 0
# 총 1+0+1+2 = 4개
#
# 백트래킹 (31원):
# 10×3 + 1×1 = 31
# 총 3+1 = 4개 (동일)
#
# 더 확실한 반례: C=[12, 10, 5, 1]에서 15원
#
# 탐욕법:
# 15 ÷ 12 = 1개, 나머지 3
#  3 ÷ 10 = 0개, 나머지 3
#  3 ÷ 5  = 0개, 나머지 3
#  3 ÷ 1  = 3개, 나머지 0
# 총 1+0+0+3 = 4개
#
# 백트래킹:
# 5×3 = 15
# 총 3개 (최적!)
#
# 결론:
# C = [25, 10, 4, 1]은 비교적 잘 설계됨
# 더 명확한 반례는 C = [12, 10, 5, 1]의 15원
# 탐욕법 4개 vs 최적해 3개]]></solution>
  </problem>

  <!-- 문제 10: 복잡도 분석 (백트래킹 vs 탐욕법) -->
  <problem>
    <description>백트래킹과 탐욕법의 시간복잡도를 Big-O 표기법으로 나타내고, 각각의 실행 시간이 어떻게 증가하는지 설명하세요.</description>
    <code><![CDATA[# 백트래킹
def backtrack(C, n):
    ans = [1e9]
    def f(w, d):
        if w == n or w > n or d >= ans[0]:
            if w == n:
                ans[0] = min(ans[0], d)
            return
        for t in C:
            f(w + t, d + 1)
    f(0, 0)
    return int(ans[0])

# 탐욕법
def greedy(C, n):
    ans = 0
    for c in C:
        ans = ans + n // c
        n = n % c
    return ans]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 백트래킹 시간복잡도:
# - 표기: O(k^(n/m))
#   k: 동전 종류 개수
#   n: 목표 금액
#   m: 최소 동전 단위
#
# 분석:
# - 재귀 트리의 각 노드에서 k개 분기
# - 최대 깊이: n/m (최소 동전으로만 채울 때)
# - 이론상 노드 수: k^(n/m)
# - 가지치기로 실제로는 훨씬 적지만 여전히 지수 시간
#
# 예: k=4, n=1000, m=10
# - 최악: 4^(1000/10) = 4^100 (천문학적)
# - 가지치기 후: 약 10^6~10^9 (수백만~수억)
#
# n에 따른 증가:
# - n=100: 약 10,000번
# - n=1000: 약 1,000,000번
# - n=10000: 약 100,000,000번 (1억)
# - 지수적 증가
#
# 탐욕법 시간복잡도:
# - 표기: O(k)
#   k: 동전 종류 개수
#
# 분석:
# - 동전 종류만큼만 반복
# - 각 반복마다 나눗셈 연산 O(1)
# - 총 k번 반복 → O(k)
# - n과 무관하게 일정
#
# 예: k=4
# - n=100: 4번
# - n=1000: 4번
# - n=10000: 4번
# - n=1000000: 4번
# - n에 무관
#
# 실행 시간 비교 (k=4):
# n=100:
# - 백트래킹: 0.001초
# - 탐욕법: 0.00001초
#
# n=1000:
# - 백트래킹: 0.1초
# - 탐욕법: 0.00001초
#
# n=10000:
# - 백트래킹: 10초
# - 탐욕법: 0.00001초
#
# n=100000:
# - 백트래킹: 수 시간 (실용 불가)
# - 탐욕법: 0.00001초
#
# 결론:
# - 백트래킹: O(k^(n/m)) - 지수 시간, n 증가 시 폭발적 증가
# - 탐욕법: O(k) - 선형 시간, n에 무관
# - 탐욕법이 압도적으로 빠르지만 최적해 보장 조건 필요
# - 조건 만족 시 탐욕법, 아니면 동적계획법 고려]]></solution>
  </problem>

  <!-- 문제 11: 디버깅 (배수 관계 확인) -->
  <problem>
    <description>다음 코드는 동전이 배수 관계인지 확인하려 합니다. 오류를 찾아 고치세요.</description>
    <code><![CDATA[def check(C):
    for i in range(len(C)):
        if C[i] % C[i+1] != 0:
            return False
    return True

C = [500, 100, 50, 10]
print(check(C))]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[def check(C):
    for i in range(len(C)-1):  # 오류: len(C)-1로 수정
        if C[i] % C[i+1] != 0:
            return False
    return True

C = [500, 100, 50, 10]
print(check(C))

# 잘못된 부분: range(len(C))
# 이유: i가 len(C)-1까지 가면 C[i+1]은 인덱스 범위 초과
#       예: len(C)=4, i=3일 때 C[4]는 존재하지 않음
# 정답: range(len(C)-1)로 수정
#       i는 0부터 len(C)-2까지
#
# 실행 결과:
# 500 % 100 = 0 (OK)
# 100 % 50 = 0 (OK)
# 50 % 10 = 0 (OK)
# 결과: True
#
# 참고:
# [500, 100, 50, 10]은 완벽한 배수 관계
# 하지만 탐욕법이 작동하는 조건은 더 복잡
# 단순 배수 관계 확인만으로는 부족할 수 있음
#
# 더 나은 확인 방법:
# - 실제로 여러 금액에 대해 탐욕법과 백트래킹 비교
# - 또는 수학적으로 증명]]></solution>
  </problem>
</problems>
