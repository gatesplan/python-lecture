"""
해밀토니안 경로 (Hamiltonian Path) - 가중치 있는 버전 (상세 설명)

문제:
- 그래프의 모든 노드를 정확히 한 번씩만 방문하는 경로
- 모든 해밀토니안 경로 중 가중치 합이 최소인 경로 찾기

알고리즘: 백트래킹 (Backtracking)
- 모든 가능한 경로를 탐색하되, 불필요한 경로는 가지치기
- 시간복잡도: O(V!) (최악의 경우, V = 노드 개수)

입력 예시:
7 11
0 1 1
0 2 3
0 3 2
0 6 5
1 2 2
2 6 4
3 4 3
3 5 4
3 6 6
4 5 1
5 6 2

출력: 최소 비용 (예: 9)
"""

# ============================================================
# 전역 변수
# ============================================================

M = []          # 그래프 (인접 리스트) - M[i] = [(인접노드, 가중치), ...]
ans = 0         # 최소 비용 (매우 큰 값으로 초기화)
visited = []    # 방문 여부 배열 - visited[i] = True/False
V, E = 0, 0     # V: 노드 개수, E: 간선 개수


# ============================================================
# 핵심 재귀 함수: 백트래킹으로 해밀토니안 경로 탐색
# ============================================================

def f(x, y, z, d):
    """
    해밀토니안 경로를 재귀적으로 탐색하는 백트래킹 함수

    파라미터:
    - x (int): 현재 방문 중인 노드 번호
    - y (int): 지금까지 방문한 노드 개수 (1부터 시작)
    - z (list): 현재까지의 경로 리스트 [시작노드, ..., 현재노드]
    - d (int): 현재까지의 가중치 합계 (누적 비용)

    작동 원리:
    1. 종료 조건: y == V (모든 노드 방문 완료)
       → 최소 비용 갱신
    2. 현재 노드 방문 표시
    3. 인접 노드 중 미방문 노드로 재귀 탐색
    4. 백트래킹: 방문 표시 해제 (다른 경로 탐색 위해)

    백트래킹 핵심:
    - 선택 (visited[x] = True)
    - 진행 (재귀 호출)
    - 되돌리기 (visited[x] = False)
    """
    global V, M, visited, ans

    # ========================================
    # 종료 조건: 모든 노드 방문 완료
    # ========================================
    if y == V:
        # 현재 경로의 비용이 최소값보다 작으면 갱신
        if ans > d:
            ans = d
            # 디버깅용: 최소 경로 출력 (주석 해제 시 경로 확인 가능)
            # print(f"새로운 최소 경로: {z}, 비용: {d}")
        return

    # ========================================
    # 백트래킹 시작: 현재 노드 방문 표시
    # ========================================
    visited[x] = True

    # ========================================
    # 인접한 노드들을 탐색
    # ========================================
    for u, w in M[x]:
        # M[x]는 [(인접노드, 가중치), ...] 형태
        # u: 인접 노드 번호
        # w: 간선의 가중치

        # 미방문 노드만 탐색
        if visited[u] == False:
            # 1. 선택: 경로에 노드 추가
            z.append(u)

            # 2. 진행: 다음 노드로 재귀 호출
            #    - 현재 노드: u
            #    - 방문 개수: y+1
            #    - 경로: z (u가 추가된 상태)
            #    - 누적 비용: d+w
            f(u, y+1, z, d+w)

            # 3. 되돌리기: 경로에서 노드 제거 (백트래킹)
            #    다른 경로를 탐색하기 위해 상태 복원
            z.pop()

    # ========================================
    # 백트래킹 완료: 방문 표시 해제
    # ========================================
    # 다른 경로에서 이 노드를 다시 방문할 수 있도록
    visited[x] = False


# ============================================================
# 초기화 및 입력 처리
# ============================================================

def init_graph():
    """그래프와 방문 배열을 초기화"""
    global M, visited, ans
    M = [[] for i in range(11)]  # 최대 11개 노드
    visited = [False for i in range(11)]
    ans = 123456789987654321  # 매우 큰 값 (무한대 대신)


def read_input():
    """그래프 정보를 입력받음"""
    global V, E

    # 첫 줄: 노드 개수 V, 간선 개수 E
    V, E = map(int, input().split())

    # E개의 간선 정보 입력
    for i in range(E):
        u, v, w = map(int, input().split())
        # u: 시작 노드
        # v: 끝 노드
        # w: 가중치

        # 무방향 그래프이므로 양쪽 모두 추가
        M[u].append((v, w))  # u → v, 가중치 w
        M[v].append((u, w))  # v → u, 가중치 w


# ============================================================
# 메인 실행
# ============================================================

def main():
    """메인 실행 함수"""
    global V, ans

    # 1. 초기화
    init_graph()

    # 2. 입력 받기
    read_input()

    # 3. 모든 시작 노드에서 해밀토니안 경로 탐색
    #    어떤 노드에서 시작하든 모든 경로를 확인해야 함
    for v in range(V):
        # v번 노드에서 시작
        # y=1 (1개 방문), z=[v] (경로에 v만 있음), d=0 (비용 0)
        f(v, 1, [v], 0)

    # 4. 결과 출력
    print(ans)


# ============================================================
# 프로그램 시작점
# ============================================================

if __name__ == "__main__":
    main()


# ============================================================
# 시간복잡도 분석
# ============================================================
"""
최악의 경우: O(V!)
- 모든 노드의 순열을 탐색해야 할 수 있음
- V=10일 때: 10! = 3,628,800번의 재귀 호출 가능
- 실제로는 그래프 구조와 가지치기로 더 적을 수 있음

백트래킹의 효과:
- visited 배열로 이미 방문한 노드 제외
- 불가능한 경로 조기 종료
- 그래프가 sparse할수록 효과적
"""

# ============================================================
# 실행 예제 및 예상 출력
# ============================================================
"""
입력:
4 6
0 1 1
0 2 3
1 2 2
1 3 4
2 3 1
0 3 10

그래프:
    0
   /|\
  1 3 10
 /| |\ |
1 2 2 1 3
 \ | /
   4

가능한 해밀토니안 경로:
- 0 → 1 → 2 → 3: 1 + 2 + 1 = 4
- 0 → 2 → 1 → 3: 3 + 2 + 4 = 9
- 0 → 2 → 3 → 1: 3 + 1 + 4 = 8
- 등등...

최소 비용: 4
"""
