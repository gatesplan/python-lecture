"""
p195 동전 최소 개수 구하기 문제 (백트래킹 방법)

문제:
- 주어진 동전 종류로 정확히 n원을 만들 때 사용하는 동전의 최소 개수

알고리즘:
- 백트래킹(Backtracking): 모든 경우의 수를 탐색하되, 가지치기로 불필요한 경로 제거
- 가지치기 조건:
  1. 금액이 목표를 초과하면 중단
  2. 이미 찾은 최소값보다 동전 개수가 많으면 중단

시간복잡도:
- 최악의 경우 O(k^(n/m)) (k: 동전 종류, n: 목표 금액, m: 최소 동전 단위)
- 가지치기로 실제로는 훨씬 적음
"""

ans = 1e9  # 매우 큰 수로 초기화 (무한대 대신 사용)
coin = [500, 100, 50, 10]
n = 1780

def f(won, d):
    """
    재귀 함수로 동전 최소 개수 계산

    Parameters:
    - won: 지금까지 사용한 금액
    - d: 지금까지 사용한 동전 개수
    """
    global ans, coin

    # 종료 조건1: 지금까지 사용한 금액이 n과 같으면
    if won == n:
        ans = min(ans, d)  # 최소 동전 개수 갱신
        return

    # 종료 조건2: 지금까지 사용한 금액이 n을 초과하면 중단
    if won > n:
        return

    # 종료 조건3: 가지치기 - 이미 찾은 최소값보다 크면 더 탐색할 필요 없음
    if d >= ans:
        return

    # 이제부터 동전을 하나씩 더 사용해 봄
    for t in coin:
        f(won + t, d + 1)

    return

# 탐색 시작
f(0, 0)
print(ans)

# 예상 결과:
# 500 × 3 = 1500
# 100 × 2 = 200
# 50 × 1 = 50
# 10 × 3 = 30
# 총 9개
