<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <problem>
    <description>주어진 코드의 출력 결과를 쓰시오.</description>
    <code><![CDATA[import queue
t = [10, 3, 7, 4, 6, 2, 8, 5, 1, 9]
s = queue.LifoQueue()
for i in t :
    while not s.empty():
        k = s.get()
        if i > k:
            print(k)
        else:
            s.put(k)
            break
    s.put(i)
while not s.empty():
    print(s.get())]]></code>
    <input><![CDATA[]]></input>
    <output><![CDATA[3
4
2
5
1
9
8
6
7
10]]></output>
    <hint></hint>
    <solution><![CDATA[# 이 알고리즘은 각 원소보다 작은 이전 원소들을 제거하고 출력합니다.

# 실행 과정:
# i=10: 스택 비어있음 → 10 삽입 → 스택: [10]
# i=3: 10 > 3 → 10 다시 삽입, 루프 종료 → 3 삽입 → 스택: [10, 3]
# i=7: 3 < 7 → 3 출력, 10 > 7 → 10 다시 삽입, 루프 종료 → 7 삽입 → 스택: [10, 7]
# i=4: 7 > 4 → 7 다시 삽입, 루프 종료 → 4 삽입 → 스택: [10, 7, 4]
# i=6: 4 < 6 → 4 출력, 7 > 6 → 7 다시 삽입, 루프 종료 → 6 삽입 → 스택: [10, 7, 6]
# i=2: 6 > 2 → 6 다시 삽입, 루프 종료 → 2 삽입 → 스택: [10, 7, 6, 2]
# i=8: 2 < 8 → 2 출력, 6 < 8 → 6 출력, 7 < 8 → 7 출력, 10 > 8 → 10 다시 삽입, 루프 종료 → 8 삽입 → 스택: [10, 8]
# i=5: 8 > 5 → 8 다시 삽입, 루프 종료 → 5 삽입 → 스택: [10, 8, 5]
# i=1: 5 > 1 → 5 다시 삽입, 루프 종료 → 1 삽입 → 스택: [10, 8, 5, 1]
# i=9: 1 < 9 → 1 출력, 5 < 9 → 5 출력, 8 < 9 → 8 출력, 10 > 9 → 10 다시 삽입, 루프 종료 → 9 삽입 → 스택: [10, 9]

# 마지막 스택 출력: 9, 10

# 출력: 3 4 2 5 1 9 10]]></solution>
  </problem>

  <problem>
    <description>t = [1, 3, 5, 7, 6, 4, 2]일 때, 세 번째로 print 함수가 실행되어 출력되는 값을 쓰시오.</description>
    <code><![CDATA[import queue
t = [1, 3, 5, 7, 6, 4, 2]
s = queue.LifoQueue()
for i in t :
    while not s.empty():
        k = s.get()
        if i > k:
            print(k)
        else:
            s.put(k)
            break
    s.put(i)
while not s.empty():
    print(s.get())]]></code>
    <input><![CDATA[]]></input>
    <output><![CDATA[5]]></output>
    <hint></hint>
    <solution><![CDATA[# 실행 과정을 추적하여 세 번째 print 호출을 찾습니다:

# i=1: 스택 비어있음 → 1 삽입 → 스택: [1]
# i=3: 1 < 3 → 1 출력 (첫 번째 print) → 3 삽입 → 스택: [3]
# i=5: 3 < 5 → 3 출력 (두 번째 print) → 5 삽입 → 스택: [5]
# i=7: 5 < 7 → 5 출력 (세 번째 print) → 7 삽입 → 스택: [7]

# 세 번째로 print 함수가 실행되어 출력되는 값: 5]]></solution>
  </problem>

  <problem>
    <description>위 코드에서 s에 LifoQueue() 대신 Queue()를 사용했을 때, 출력 결과를 쓰시오.</description>
    <code><![CDATA[import queue
t = [10, 3, 7, 4, 6, 2, 8, 5, 1, 9]
s = queue.Queue()  # LifoQueue() 대신 Queue() 사용
for i in t :
    while not s.empty():
        k = s.get()
        if i > k:
            print(k)
        else:
            s.put(k)
            break
    s.put(i)
while not s.empty():
    print(s.get())]]></code>
    <input><![CDATA[]]></input>
    <output><![CDATA[10
3
7
4
6
2
8
5
1
9]]></output>
    <hint></hint>
    <solution><![CDATA[# Queue()는 FIFO(First In First Out) 방식으로 동작합니다.
# LifoQueue()와 달리 먼저 들어간 원소가 먼저 나옵니다.

# Queue 사용 시:
# - 각 단계에서 큐의 가장 앞 원소부터 비교
# - 조건에 맞지 않으면 다시 큐의 뒤로 삽입
# - 결과적으로 모든 원소가 순서대로 출력됨

# 출력: 10 3 7 4 6 2 8 5 1 9 (입력 순서와 동일)]]></solution>
  </problem>
</problems>