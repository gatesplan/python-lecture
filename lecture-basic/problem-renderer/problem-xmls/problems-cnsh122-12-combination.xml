<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: 출력 예측 (조합 결과) - 워밍업 -->
  <problem>
    <description>다음 코드의 출력 결과를 쓰세요.</description>
    <code><![CDATA[A = [1, 2, 3, 4, 5]
ans = 0

def f(k, s, j):
    if j == 3:
        if s > 8:
            global ans
            ans += 1
        return
    for i in range(k+1, 5):
        f(i, s+A[i], j+1)

f(-1, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[6]]></output>
    <solution><![CDATA[# 3개 선택하여 합이 8보다 큰 조합의 개수
# 가능한 조합:
# [1,2,3]=6 (X), [1,2,4]=7 (X), [1,2,5]=8 (X)
# [1,3,4]=8 (X), [1,3,5]=9 (O), [1,4,5]=10 (O)
# [2,3,4]=9 (O), [2,3,5]=10 (O), [2,4,5]=11 (O)
# [3,4,5]=12 (O)
# 합이 8보다 큰 경우: 6가지
# 정답: 6]]></solution>
  </problem>

  <!-- 문제 2: 서술형 (파라미터 k, s, j 의미) -->
  <problem>
    <description>다음 조합 선택 재귀 함수 f의 세 파라미터 k, s, j가 각각 무엇을 의미하는지 서술하세요.</description>
    <code><![CDATA[A = [2, 4, 6, 8, 10]
ans = 0

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return
    for i in range(k+1, 5):
        f(i, s+A[i], j+1)

f(-1, 0, 0)
print(ans)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 파라미터 의미:
# k: 현재까지 탐색한 인덱스 (마지막으로 선택한 원소의 인덱스)
#    조합에서 중복 방지를 위해 k+1부터 탐색 시작
# s: 현재까지 선택한 원소들의 합
#    조건 확인 및 결과 계산에 사용
# j: 현재까지 선택한 원소의 개수 (선택 깊이)
#    종료 조건(j==3)에 도달했는지 확인]]></solution>
  </problem>

  <!-- 문제 3: 빈칸 채우기 (종료 조건) -->
  <problem>
    <description>다음 코드는 배열에서 3개를 선택하여 합이 3의 배수인 경우 중 최댓값을 구하는 재귀 함수입니다. 종료 조건을 완성하세요.</description>
    <code><![CDATA[A = [1, 3, 5, 7, 9, 11]
ans = -1

def f(k, s, j):
    if ____:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return
    for i in range(k+1, 6):
        f(i, s+A[i], j+1)

f(-1, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[27]]></output>
    <solution><![CDATA[A = [1, 3, 5, 7, 9, 11]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return
    for i in range(k+1, 6):
        f(i, s+A[i], j+1)

f(-1, 0, 0)
print(ans)

# 정답: j == 3
# 3개를 선택했을 때 종료하는 조건]]></solution>
  </problem>

  <!-- 문제 4: 빈칸 채우기 (ans 갱신) -->
  <problem>
    <description>다음 코드는 배열에서 3개를 선택하여 합이 짝수인 경우 중 최솟값을 구하는 재귀 함수입니다. ans 갱신 부분을 완성하세요.</description>
    <code><![CDATA[A = [1, 2, 3, 4, 5, 6]
ans = 999

def f(k, s, j):
    if j == 3:
        if (s%2) == 0:
            global ans
            ans = ____
        return
    for i in range(k+1, 6):
        f(i, s+A[i], j+1)

f(-1, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[6]]></output>
    <solution><![CDATA[A = [1, 2, 3, 4, 5, 6]
ans = 999

def f(k, s, j):
    if j == 3:
        if (s%2) == 0:
            global ans
            ans = min(ans, s)
        return
    for i in range(k+1, 6):
        f(i, s+A[i], j+1)

f(-1, 0, 0)
print(ans)

# 정답: min(ans, s)
# 최솟값을 구하므로 min 함수 사용
# 가능한 조합 중 합이 짝수인 것: [1,2,3]=6, [1,3,4]=8, ...
# 최솟값은 6]]></solution>
  </problem>

  <!-- 문제 5: 디버깅 (range 오류) -->
  <problem>
    <description>다음 코드는 배열에서 3개를 선택하여 합이 3의 배수인 경우의 개수를 구하려 하지만 오류가 있습니다. 오류를 찾아 고치세요.</description>
    <code><![CDATA[A = [2, 4, 6, 8, 10]
ans = 0

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans += 1
        return
    for i in range(k, 5):
        f(i, s+A[i], j+1)

f(0, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[4]]></output>
    <solution><![CDATA[A = [2, 4, 6, 8, 10]
ans = 0

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans += 1
        return
    for i in range(k+1, 5):
        f(i, s+A[i], j+1)

f(-1, 0, 0)
print(ans)

# 오류 1: range(k, 5) → range(k+1, 5)
# 이유: k번째 원소를 이미 선택했으므로 k+1부터 탐색해야 함
# 그렇지 않으면 같은 원소를 중복 선택하게 됨
#
# 오류 2: f(0, 0, 0) → f(-1, 0, 0)
# 이유: 0번 인덱스부터 시작하려면 k=-1로 초기화
# 첫 for문에서 range(0, 5)가 되어 0부터 탐색 가능]]></solution>
  </problem>

  <!-- 문제 6: 트레이싱 (재귀 호출 과정) -->
  <problem>
    <description>다음 코드에서 f(-1, 0, 0)을 실행할 때, f 함수가 총 몇 번 호출되는지 구하세요.</description>
    <code><![CDATA[A = [1, 2, 3]
ans = 0

def f(k, s, j):
    if j == 2:
        global ans
        ans += 1
        return
    for i in range(k+1, 3):
        f(i, s+A[i], j+1)

f(-1, 0, 0)
print(ans)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 재귀 트리 추적:
# f(-1, 0, 0)
#   f(0, 1, 1)
#     f(1, 3, 2) - 종료
#     f(2, 4, 2) - 종료
#   f(1, 2, 1)
#     f(2, 5, 2) - 종료
#   f(2, 3, 1) - for문 진입 못함 (range(3, 3)은 빈 범위)
#
# 호출 횟수:
# f(-1,0,0): 1번
# f(0,1,1): 1번
# f(1,3,2): 1번
# f(2,4,2): 1번
# f(1,2,1): 1번
# f(2,5,2): 1번
# f(2,3,1): 1번
# 총 7번
#
# 또는 공식으로: C(3,2) = 3가지 조합 + 중간 노드
# 정답: 7번]]></solution>
  </problem>

  <!-- 문제 7: 전체 작성 (3개 선택 3의 배수) -->
  <problem>
    <description>배열 A에서 3개를 선택하여 합이 3의 배수인 경우 중 최댓값을 구하는 재귀 함수를 작성하세요. 배열 크기는 n입니다.</description>
    <code><![CDATA[A = [5, 7, 11, 13, 17, 19]
n = 6
ans = -1

def f(k, s, j):
    pass

f(-1, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[39]]></output>
    <solution><![CDATA[A = [5, 7, 11, 13, 17, 19]
n = 6
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return
    for i in range(k+1, n):
        f(i, s+A[i], j+1)

f(-1, 0, 0)
print(ans)

# 조합 선택 패턴:
# 1. 종료 조건: j개를 선택했으면 조건 확인
# 2. 재귀: k+1부터 n-1까지 순회하며 선택
# 3. 파라미터: (선택한 인덱스, 현재 합, 선택 개수)
#
# 3의 배수인 조합 찾기:
# [5,11,17]=33 (O), [7,13,19]=39 (O)
# 최댓값: 39]]></solution>
  </problem>

  <!-- 문제 8: 전체 작성 (n개 중 r개 일반화) -->
  <problem>
    <description>배열 A의 n개 원소 중 r개를 선택하여 합이 최대가 되는 값을 구하는 재귀 함수를 작성하세요.</description>
    <code><![CDATA[A = [3, 5, 7, 9, 11]
n = 5
r = 3
ans = -1

def f(k, s, j):
    pass

f(-1, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[27]]></output>
    <solution><![CDATA[A = [3, 5, 7, 9, 11]
n = 5
r = 3
ans = -1

def f(k, s, j):
    if j == r:
        global ans
        ans = max(ans, s)
        return
    for i in range(k+1, n):
        f(i, s+A[i], j+1)

f(-1, 0, 0)
print(ans)

# n개 중 r개 선택 패턴:
# 종료 조건을 j == r로 일반화
# r=3일 때 3개 선택 완료 시 종료
# 최댓값: [7, 9, 11] = 27]]></solution>
  </problem>

  <!-- 문제 9: 조건 역추론 (특정 합 만드는 조합) -->
  <problem>
    <description>다음 코드의 출력이 4가 나오려면 빈칸에 들어갈 조건식을 쓰세요.</description>
    <code><![CDATA[A = [1, 2, 3, 4, 5, 6]
ans = 0

def f(k, s, j):
    if j == 2:
        if ____:
            global ans
            ans += 1
        return
    for i in range(k+1, 6):
        f(i, s+A[i], j+1)

f(-1, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[4]]></output>
    <solution><![CDATA[A = [1, 2, 3, 4, 5, 6]
ans = 0

def f(k, s, j):
    if j == 2:
        if s >= 10:
            global ans
            ans += 1
        return
    for i in range(k+1, 6):
        f(i, s+A[i], j+1)

f(-1, 0, 0)
print(ans)

# 정답: s >= 10
# 2개 선택 조합의 합: [1,2]=3, [1,3]=4, [1,4]=5, [1,5]=6, [1,6]=7
# [2,3]=5, [2,4]=6, [2,5]=7, [2,6]=8
# [3,4]=7, [3,5]=8, [3,6]=9
# [4,5]=9, [4,6]=10, [5,6]=11
# 합이 10 이상: [4,6]=10, [5,6]=11, 2개만
# 재계산: s > 8이면? [3,6]=9 (X), [4,5]=9 (X), [4,6]=10 (O), [5,6]=11 (O)
# 2개뿐, 4개를 만들려면 다른 조건 필요
# s >= 9: [3,6]=9, [4,5]=9, [4,6]=10, [5,6]=11 = 4개
# 정답: s >= 9]]></solution>
  </problem>

  <!-- 문제 10: 코드 비교 (최댓값 vs 개수 세기) -->
  <problem>
    <description>다음 두 코드 A와 B의 차이점을 설명하고, 각각의 출력값을 구하세요.</description>
    <code><![CDATA[A = [2, 5, 8, 11]

# 코드 A
ans = -1
def f(k, s, j):
    if j == 2:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return
    for i in range(k+1, 4):
        f(i, s+A[i], j+1)
f(-1, 0, 0)

# 코드 B
cnt = 0
def g(k, s, j):
    if j == 2:
        if (s%3) == 0:
            global cnt
            cnt += 1
        return
    for i in range(k+1, 4):
        g(i, s+A[i], j+1)
g(-1, 0, 0)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 코드 A: 최댓값 구하기
# - 조건을 만족하는 조합 중 합의 최댓값을 구함
# - ans = max(ans, s)로 최댓값 갱신
# - 2개 선택 조합: [2,5]=7, [2,8]=10, [2,11]=13
#   [5,8]=13, [5,11]=16, [8,11]=19
# - 3의 배수: 15는 없음, 재계산
# - [2,5]=7 (X), [2,8]=10 (X), [2,11]=13 (X)
# - [5,8]=13 (X), [5,11]=16 (X), [8,11]=19 (X)
# - 3의 배수 없으면 ans=-1
# - 출력: -1
#
# 코드 B: 개수 세기
# - 조건을 만족하는 조합의 개수를 셈
# - cnt += 1로 개수 누적
# - 3의 배수인 조합이 없으므로 cnt=0
# - 출력: 0
#
# 차이점:
# - A는 max를 사용하여 최댓값 추적
# - B는 += 1을 사용하여 개수 카운트
# - A는 초기값 -1 (최댓값), B는 초기값 0 (개수)
# - 같은 조합 탐색 구조이지만 결과 처리 방식이 다름]]></solution>
  </problem>

  <!-- 문제 11: 순서 맞추기 (조합 함수 줄) -->
  <problem>
    <description>다음은 n개 중 r개를 선택하여 곱이 최대가 되는 조합을 구하는 재귀 함수의 줄을 섞어놓은 것입니다. 올바른 순서로 배열하세요.

A. if j == r:
B. for i in range(k+1, n):
C. global ans
D. f(i, p*A[i], j+1)
E. ans = max(ans, p)
F. return</description>
    <code><![CDATA[A = [2, 3, 5, 7]
n = 4
r = 2
ans = -1

def f(k, p, j):
    # 여기에 위 줄들을 올바른 순서로 배치
    pass

f(-1, 1, 0)
print(ans)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 올바른 순서: A - C - E - F - B - D
#
# 정답 코드:
A = [2, 3, 5, 7]
n = 4
r = 2
ans = -1

def f(k, p, j):
    if j == r:
        global ans
        ans = max(ans, p)
        return
    for i in range(k+1, n):
        f(i, p*A[i], j+1)

f(-1, 1, 0)
print(ans)

# 설명:
# 1. 종료 조건 확인 (A)
# 2. 전역 변수 선언 (C)
# 3. 결과 갱신 (E)
# 4. 종료 (F)
# 5. 반복문 시작 (B)
# 6. 재귀 호출 (D)
#
# 출력: 35 (5×7)]]></solution>
  </problem>

  <!-- 문제 12: 복잡도 분석 (조합 알고리즘) -->
  <problem>
    <description>n개 원소 중 r개를 선택하는 조합 재귀 알고리즘의 시간복잡도를 분석하고, n=10, r=3일 때 대략적인 함수 호출 횟수를 계산하세요.</description>
    <code><![CDATA[def f(k, s, j):
    if j == r:
        return 1
    cnt = 0
    for i in range(k+1, n):
        cnt += f(i, s+A[i], j+1)
    return cnt]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 시간복잡도 분석:
# - 조합의 개수: C(n, r) = n! / (r! × (n-r)!)
# - 재귀 트리의 내부 노드도 포함하면 더 많음
#
# 정확한 분석:
# - 각 깊이 j에서 선택 가능한 원소 수: n-j
# - 깊이 0: n개, 깊이 1: 최대 n-1개, 깊이 2: 최대 n-2개
# - 전체 호출 횟수는 약 C(n, r) + 중간 노드
# - 최악의 경우: O(n^r)
# - 실제로는 C(n, r) × r (각 조합을 만들기 위한 재귀 경로)
#
# n=10, r=3일 때:
# - C(10, 3) = 10! / (3! × 7!) = 120가지 조합
# - 각 조합을 만들기 위해 깊이 3까지 탐색
# - 재귀 트리 노드 수:
#   깊이 0: 1개
#   깊이 1: 10개 (0부터 9까지 선택)
#   깊이 2: C(10,1)×9 + ... 대략 45개
#   깊이 3: 120개 (종료 노드)
# - 총 호출 횟수: 약 1 + 10 + 45 + 120 = 176번
#
# 공식:
# T(n, r) = Σ(k=0 to r) C(n, k)
# n=10, r=3: C(10,0) + C(10,1) + C(10,2) + C(10,3)
#           = 1 + 10 + 45 + 120 = 176번
#
# 시간복잡도: O(C(n, r)) = O(n^r / r!)
# 공간복잡도: O(r) (재귀 깊이)
#
# 결론: n=10, r=3일 때 약 176번 호출]]></solution>
  </problem>
</problems>
