<?xml version="1.0" encoding="UTF-8"?>
<!--
  재귀함수 중급 연습 문제 - Expert 레벨
  
  이 파일은 재귀함수 기초를 익힌 학습자를 위한 중급 문제들입니다.
  Apprentice 레벨보다 복잡한 조건문, 이중 재귀, 분할정복 개념을 다룹니다.
  
  학습 목표:
  - 조건부 재귀와 복합 기저 조건 처리
  - 이중 재귀 호출 (피보나치 등) 이해
  - 분할정복 사고방식 적용
  - 복수 매개변수를 활용한 재귀 구현
-->
<problems>

  <!-- =========================== Apprentice 변형 =========================== -->
  
  <!-- 1. 1부터 n까지 짝수의 합 -->
  <problem>
    <description>재귀함수를 사용하여 1부터 n까지의 수 중에서 짝수만 더한 값을 계산하는 함수를 작성하세요.
예: n=6일 때 2+4+6 = 12</description>
    <code><![CDATA[def sum_even(n):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA[6]]></input>
    <output><![CDATA[12]]></output>
    <solution><![CDATA[def sum_even(n):
    # 기저 조건: n이 0 이하이면 0 반환
    if n <= 0:
        return 0
    
    # n이 짝수인지 확인
    if n % 2 == 0:
        # 짝수이면 n을 더하고 재귀 호출
        return n + sum_even(n - 1)
    else:
        # 홀수이면 더하지 않고 재귀 호출
        return sum_even(n - 1)]]></solution>
  </problem>

  <!-- 2. 1부터 n까지 홀수의 합 -->
  <problem>
    <description>재귀함수를 사용하여 1부터 n까지의 수 중에서 홀수만 더한 값을 계산하는 함수를 작성하세요.
예: n=6일 때 1+3+5 = 9</description>
    <code><![CDATA[def sum_odd(n):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA[6]]></input>
    <output><![CDATA[9]]></output>
    <solution><![CDATA[def sum_odd(n):
    # 기저 조건: n이 0 이하이면 0 반환
    if n <= 0:
        return 0
    
    # n이 홀수인지 확인
    if n % 2 == 1:
        # 홀수이면 n을 더하고 재귀 호출
        return n + sum_odd(n - 1)
    else:
        # 짝수이면 더하지 않고 재귀 호출
        return sum_odd(n - 1)]]></solution>
  </problem>

  <!-- 3. 숫자 뒤집기 -->
  <problem>
    <description>재귀함수를 사용하여 주어진 양의 정수를 뒤집은 값을 반환하는 함수를 작성하세요.
예: 1234 → 4321, 567 → 765</description>
    <code><![CDATA[def reverse_number(n, reversed_n=0):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA[1234]]></input>
    <output><![CDATA[4321]]></output>
    <solution><![CDATA[def reverse_number(n, reversed_n=0):
    # 기저 조건: n이 0이면 뒤집은 결과 반환
    if n == 0:
        return reversed_n
    
    # 재귀 호출: 마지막 자릿수를 reversed_n에 추가하고,
    # n에서 마지막 자릿수를 제거
    return reverse_number(n // 10, reversed_n * 10 + n % 10)

# 더 이해하기 쉬운 버전 (내부 함수 사용):
def reverse_number_v2(n):
    def helper(num, result):
        if num == 0:
            return result
        return helper(num // 10, result * 10 + num % 10)
    
    return helper(n, 0)]]></solution>
  </problem>

  <!-- 4. 배열에서 특정 값 개수 -->
  <problem>
    <description>재귀함수를 사용하여 리스트에서 특정 값이 몇 개 있는지 세는 함수를 작성하세요.
예: [1, 2, 1, 3, 1, 4]에서 1은 3개</description>
    <code><![CDATA[def count_value(arr, target):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA[arr=[1, 2, 1, 3, 1, 4], target=1]]></input>
    <output><![CDATA[3]]></output>
    <solution><![CDATA[def count_value(arr, target):
    # 기저 조건: 빈 리스트이면 0 반환
    if not arr:
        return 0
    
    # 첫 번째 원소가 찾는 값과 같은지 확인
    if arr[0] == target:
        # 같으면 1을 더하고 나머지 리스트 확인
        return 1 + count_value(arr[1:], target)
    else:
        # 다르면 0을 더하고 나머지 리스트 확인
        return 0 + count_value(arr[1:], target)

# 더 간단한 버전:
def count_value_simple(arr, target):
    if not arr:
        return 0
    return (1 if arr[0] == target else 0) + count_value_simple(arr[1:], target)]]></solution>
  </problem>

  <!-- 5. 배열 최댓값 찾기 (분할정복) -->
  <problem>
    <description>재귀함수를 사용하여 리스트에서 가장 큰 값을 찾는 함수를 작성하세요. (분할정복 방식)
빈 리스트가 입력되지 않는다고 가정합니다.</description>
    <code><![CDATA[def find_max(arr):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA[[3, 7, 1, 9, 2]]]></input>
    <output><![CDATA[9]]></output>
    <solution><![CDATA[def find_max(arr):
    # 기저 조건: 리스트에 원소가 1개면 그 원소가 최댓값
    if len(arr) == 1:
        return arr[0]
    
    # 재귀 호출: 나머지 원소들 중 최댓값 찾기
    max_of_rest = find_max(arr[1:])
    
    # 첫 번째 원소와 나머지 중 최댓값을 비교
    return max(arr[0], max_of_rest)

# 더 간단한 버전:
def find_max_simple(arr):
    if len(arr) == 1:
        return arr[0]
    return max(arr[0], find_max_simple(arr[1:]))]]></solution>
  </problem>

  <!-- 6. 배열 최솟값 찾기 (분할정복) -->
  <problem>
    <description>재귀함수를 사용하여 리스트에서 가장 작은 값을 찾는 함수를 작성하세요. (분할정복 방식)
빈 리스트가 입력되지 않는다고 가정합니다.</description>
    <code><![CDATA[def find_min(arr):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA[[3, 7, 1, 9, 2]]]></input>
    <output><![CDATA[1]]></output>
    <solution><![CDATA[def find_min(arr):
    # 기저 조건: 리스트에 원소가 1개면 그 원소가 최솟값
    if len(arr) == 1:
        return arr[0]
    
    # 재귀 호출: 나머지 원소들 중 최솟값 찾기
    min_of_rest = find_min(arr[1:])
    
    # 첫 번째 원소와 나머지 중 최솟값을 비교
    return min(arr[0], min_of_rest)

# 더 간단한 버전:
def find_min_simple(arr):
    if len(arr) == 1:
        return arr[0]
    return min(arr[0], find_min_simple(arr[1:]))]]></solution>
  </problem>

  <!-- =========================== 이중 재귀 기초 =========================== -->

  <!-- 7. 피보나치 수열 -->
  <problem>
    <description>재귀함수를 사용하여 피보나치 수열의 n번째 값을 계산하는 함수를 작성하세요.
피보나치 수열: F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n≥2)
예: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...</description>
    <code><![CDATA[def fibonacci(n):
    # 여기에 코드를 작성하세요
    pass

# 테스트
]]></code>
    <input><![CDATA[6]]></input>
    <output><![CDATA[8]]></output>
    <solution><![CDATA[def fibonacci(n):
    # 기저 조건: F(0) = 0, F(1) = 1
    if n == 0:
        return 0
    if n == 1:
        return 1
    
    # 재귀 호출: F(n) = F(n-1) + F(n-2)
    return fibonacci(n - 1) + fibonacci(n - 2)

# 동작 과정 예시 (fibonacci(5)):
#                    fib(5)
#                   /      \
#               fib(4)    fib(3)
#               /    \    /     \
#           fib(3) fib(2) fib(2) fib(1)
#           /  \   /  \   /  \     |
#       fib(2) fib(1) fib(1) fib(0) fib(1) fib(0)  1
#       /  \     |     |     |     |     |
#   fib(1) fib(0) 1     1     0     1     0
#     |     |
#     1     0
#
# 결과: fib(5) = 5

# 참고: 이 방법은 같은 값을 여러 번 계산하므로 비효율적입니다.
# 실제로는 메모이제이션이나 동적 프로그래밍을 사용해야 합니다.]]></solution>
  </problem>

  <!-- 8. 조합 계산하기 -->
  <problem>
    <description>재귀함수를 사용하여 조합 nCr을 계산하는 함수를 작성하세요.
조합의 점화식: nCr = (n-1)C(r-1) + (n-1)Cr
기저 조건: nC0 = 1, nCn = 1</description>
    <code><![CDATA[def combination(n, r):
    # 여기에 코드를 작성하세요
    pass

# 테스트
]]></code>
    <input><![CDATA[n=5, r=2]]></input>
    <output><![CDATA[10]]></output>
    <solution><![CDATA[def combination(n, r):
    # 기저 조건
    if r == 0 or r == n:
        return 1
    
    # 재귀 호출: nCr = (n-1)C(r-1) + (n-1)Cr
    return combination(n - 1, r - 1) + combination(n - 1, r)

]]></solution>
  </problem>

  <!-- =========================== 문자열 고급 처리 =========================== -->

  <!-- 9. 문자열 뒤집기 -->
  <problem>
    <description>재귀함수를 사용하여 문자열을 뒤집는 함수를 작성하세요.
예: "hello" → "olleh", "python" → "nohtyp"</description>
    <code><![CDATA[def reverse_string(s):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA["hello"]]></input>
    <output><![CDATA["olleh"]]></output>
    <solution><![CDATA[def reverse_string(s):
    # 기저 조건: 빈 문자열이거나 한 글자이면 그대로 반환
    if len(s) <= 1:
        return s
    
    # 재귀 호출: 첫 글자를 제외한 나머지를 뒤집고, 첫 글자를 뒤에 붙임
    return reverse_string(s[1:]) + s[0]

]]></solution>
  </problem>

  <!-- 10. 회문(팰린드롬) 검사 -->
  <problem>
    <description>재귀함수를 사용하여 주어진 문자열이 회문(앞뒤가 같은 문자열)인지 확인하는 함수를 작성하세요.
예: "racecar"는 회문, "hello"는 회문이 아님</description>
    <code><![CDATA[def is_palindrome(s):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA["racecar"]]></input>
    <output><![CDATA[True]]></output>
    <solution><![CDATA[def is_palindrome(s):
    # 기저 조건: 빈 문자열이거나 한 글자이면 회문
    if len(s) <= 1:
        return True
    
    # 첫 글자와 마지막 글자 비교
    if s[0] != s[-1]:
        return False
    
    # 첫 글자와 마지막 글자를 제거한 가운데 부분을 재귀적으로 검사
    return is_palindrome(s[1:-1])

# 대소문자를 무시하고 싶다면:
def is_palindrome_case_insensitive(s):
    s = s.lower()  # 모두 소문자로 변환
    if len(s) <= 1:
        return True
    if s[0] != s[-1]:
        return False
    return is_palindrome_case_insensitive(s[1:-1])]]></solution>
  </problem>

  <!-- 11. 특정 문자 모두 제거 -->
  <problem>
    <description>재귀함수를 사용하여 문자열에서 특정 문자를 모두 제거하는 함수를 작성하세요.
예: "hello world"에서 'l'을 제거하면 "heo word"</description>
    <code><![CDATA[def remove_char(s, char):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA[s="hello world", char='l']]></input>
    <output><![CDATA["heo word"]]></output>
    <solution><![CDATA[def remove_char(s, char):
    # 기저 조건: 빈 문자열이면 빈 문자열 반환
    if not s:
        return ""
    
    # 첫 글자가 제거할 문자와 같은지 확인
    if s[0] == char:
        # 같으면 첫 글자를 제외하고 나머지 부분을 처리
        return remove_char(s[1:], char)
    else:
        # 다르면 첫 글자를 포함해서 나머지 부분을 처리
        return s[0] + remove_char(s[1:], char)

# 여러 문자를 한 번에 제거하고 싶다면:
def remove_chars(s, chars_to_remove):
    if not s:
        return ""
    if s[0] in chars_to_remove:
        return remove_chars(s[1:], chars_to_remove)
    else:
        return s[0] + remove_chars(s[1:], chars_to_remove)]]></solution>
  </problem>

  <!-- 12. 대소문자 토글 -->
  <problem>
    <description>재귀함수를 사용하여 문자열의 각 문자를 대소문자 변환하는 함수를 작성하세요.
대문자는 소문자로, 소문자는 대문자로 변환합니다.
예: "Hello World" → "hELLO wORLD"</description>
    <code><![CDATA[def toggle_case(s):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA["Hello World"]]></input>
    <output><![CDATA["hELLO wORLD"]]></output>
    <solution><![CDATA[def toggle_case(s):
    # 기저 조건: 빈 문자열이면 빈 문자열 반환
    if not s:
        return ""
    
    # 첫 글자의 대소문자 변환
    first_char = s[0]
    if first_char.islower():
        toggled_first = first_char.upper()
    elif first_char.isupper():
        toggled_first = first_char.lower()
    else:
        # 알파벳이 아닌 경우 그대로
        toggled_first = first_char
    
    # 변환된 첫 글자 + 나머지 부분을 재귀 처리
    return toggled_first + toggle_case(s[1:])

# 더 간단한 버전 (swapcase 메소드 활용):
def toggle_case_simple(s):
    if not s:
        return ""
    return s[0].swapcase() + toggle_case_simple(s[1:])

]]></solution>
  </problem>

  <!-- =========================== 수학 중급 =========================== -->

  <!-- 13. 최대공약수 (GCD) -->
  <problem>
    <description>재귀함수를 사용하여 두 양의 정수의 최대공약수를 구하는 함수를 작성하세요. (유클리드 호제법)
유클리드 호제법: gcd(a, b) = gcd(b, a mod b), gcd(a, 0) = a</description>
    <code><![CDATA[def gcd(a, b):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA[a=48, b=18]]></input>
    <output><![CDATA[6]]></output>
    <hint><![CDATA[유클리드 호제법의 원리를 생각해보세요. 언제 알고리즘이 끝나고, 어떻게 문제를 작게 만들까요?]]></hint>
    <solution><![CDATA[def gcd(a, b):
    # 기저 조건: b가 0이면 a가 최대공약수
    if b == 0:
        return a
    
    # 재귀 호출: 유클리드 호제법 적용
    return gcd(b, a % b)

# 동작 과정 예시:
# gcd(48, 18) = gcd(18, 48 % 18) = gcd(18, 12)
#             = gcd(12, 18 % 12) = gcd(12, 6)
#             = gcd(6, 12 % 6)   = gcd(6, 0)
#             = 6

# 유클리드 호제법의 원리:
# 두 수 a, b의 최대공약수는 
# b와 a를 b로 나눈 나머지의 최대공약수와 같습니다.
# 이 과정을 나머지가 0이 될 때까지 반복하면
# 마지막에 남은 수가 최대공약수입니다.

# 최소공배수도 구할 수 있습니다:
def lcm(a, b):
    return (a * b) // gcd(a, b)

]]></solution>
  </problem>

  <!-- 14. 콜라츠 추측 (3n+1 문제) -->
  <problem>
    <description>재귀함수를 사용하여 콜라츠 추측 문제를 해결하세요.
규칙: n이 짝수이면 2로 나누고, 홀수이면 3을 곱하고 1을 더합니다.
1에 도달할 때까지 몇 번의 단계가 필요한지 계산하세요.</description>
    <code><![CDATA[def collatz_steps(n):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA[3]]></input>
    <output><![CDATA[7]]></output>
    <hint><![CDATA[콜라츠 추측의 규칙을 따라 짝수와 홀수에 따라 다르게 처리하세요. 단계 수를 세는 것도 잊지 마세요.]]></hint>
    <solution><![CDATA[def collatz_steps(n):
    # 기저 조건: n이 1이면 더 이상 단계가 필요 없음
    if n == 1:
        return 0
    
    # n이 짝수인 경우
    if n % 2 == 0:
        return 1 + collatz_steps(n // 2)
    # n이 홀수인 경우
    else:
        return 1 + collatz_steps(3 * n + 1)

# 과정을 보여주는 버전:
def collatz_sequence(n):
    """콜라츠 수열을 출력하면서 단계 수를 계산"""
    def helper(num, steps):
        print(num, end=" → " if num != 1 else "\n")
        if num == 1:
            return steps
        
        if num % 2 == 0:
            return helper(num // 2, steps + 1)
        else:
            return helper(3 * num + 1, steps + 1)
    
    return helper(n, 0)

# 테스트
]]></solution>
  </problem>

  <!-- =========================== 탐색 알고리즘 =========================== -->

  <!-- 15. 이진 탐색 -->
  <problem>
    <description>재귀함수를 사용하여 정렬된 리스트에서 특정 값을 이진 탐색으로 찾는 함수를 작성하세요.
값이 있으면 인덱스를, 없으면 -1을 반환합니다.</description>
    <code><![CDATA[def binary_search(arr, target, left=0, right=None):
    # right가 None이면 배열 끝으로 설정
    if right is None:
        right = len(arr) - 1
    
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA[arr=[1,3,5,7,9,11,13,15], target=7]]></input>
    <output><![CDATA[3]]></output>
    <hint><![CDATA[이진 탐색의 핵심은 탐색 범위를 반으로 줄여나가는 것입니다. 언제 탐색이 실패할지, 어떻게 범위를 줄일지 생각해보세요.]]></hint>
    <solution><![CDATA[def binary_search(arr, target, left=0, right=None):
    # right가 None이면 배열 끝으로 설정
    if right is None:
        right = len(arr) - 1
    
    # 기저 조건: 탐색 범위가 유효하지 않으면 찾지 못함
    if left > right:
        return -1
    
    # 중간 인덱스 계산
    mid = (left + right) // 2
    
    # 중간값과 target 비교
    if arr[mid] == target:
        # 찾았으면 인덱스 반환
        return mid
    elif arr[mid] < target:
        # 중간값이 target보다 작으면 오른쪽 절반 탐색
        return binary_search(arr, target, mid + 1, right)
    else:
        # 중간값이 target보다 크면 왼쪽 절반 탐색
        return binary_search(arr, target, left, mid - 1)

# 시간 복잡도: O(log n)
# 매번 탐색 범위를 절반으로 줄여나가기 때문]]></solution>
  </problem>

  <!-- 16. 배열에서 값의 인덱스 찾기 -->
  <problem>
    <description>재귀함수를 사용하여 리스트에서 특정 값이 처음 나타나는 인덱스를 찾는 함수를 작성하세요.
값이 없으면 -1을 반환합니다. (선형 탐색의 재귀 구현)</description>
    <code><![CDATA[def find_index(arr, target, index=0):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA[arr=[1,3,5,7,3], target=3]]></input>
    <output><![CDATA[1]]></output>
    <solution><![CDATA[def find_index(arr, target, index=0):
    # 기저 조건: 인덱스가 배열 범위를 벗어나면 찾지 못함
    if index >= len(arr):
        return -1
    
    # 현재 위치의 값이 target과 같은지 확인
    if arr[index] == target:
        return index
    
    # 다음 인덱스를 재귀적으로 탐색
    return find_index(arr, target, index + 1)

# 슬라이싱을 사용한 버전:
def find_index_slice(arr, target):
    # 빈 배열이면 찾지 못함
    if not arr:
        return -1
    
    # 첫 번째 원소가 target과 같으면 0 반환
    if arr[0] == target:
        return 0
    
    # 나머지 부분에서 재귀 탐색
    rest_index = find_index_slice(arr[1:], target)
    
    # 나머지 부분에서 찾지 못했으면 -1
    if rest_index == -1:
        return -1
    
    # 나머지 부분에서 찾았으면 인덱스에 1을 더함
    return rest_index + 1

# 마지막 등장 인덱스를 찾고 싶다면:
def find_last_index(arr, target, index=None):
    if index is None:
        index = len(arr) - 1
    
    if index < 0:
        return -1
    
    if arr[index] == target:
        return index
    
    return find_last_index(arr, target, index - 1)]]></solution>
  </problem>

  <!-- 17. 조건 만족 원소 개수 -->
  <problem>
    <description>재귀함수를 사용하여 리스트에서 특정 조건을 만족하는 원소의 개수를 세는 함수를 작성하세요.
예제에서는 짝수인 원소의 개수를 세는 함수를 작성합니다.</description>
    <code><![CDATA[def count_even(arr):
    # 여기에 코드를 작성하세요
    pass]]></code>
    <input><![CDATA[[1, 2, 3, 4, 5, 6]]]></input>
    <output><![CDATA[3]]></output>
    <solution><![CDATA[def count_even(arr):
    # 기저 조건: 빈 리스트이면 0 반환
    if not arr:
        return 0
    
    # 첫 번째 원소가 짝수인지 확인
    if arr[0] % 2 == 0:
        # 짝수이면 1을 더하고 나머지 부분 처리
        return 1 + count_even(arr[1:])
    else:
        # 홀수이면 0을 더하고 나머지 부분 처리
        return 0 + count_even(arr[1:])

# 더 간단한 버전:
def count_even_simple(arr):
    if not arr:
        return 0
    return (1 if arr[0] % 2 == 0 else 0) + count_even_simple(arr[1:])

# 일반적인 조건 함수를 받는 버전:
def count_condition(arr, condition_func):
    """주어진 조건 함수를 만족하는 원소의 개수를 센다"""
    if not arr:
        return 0
    return (1 if condition_func(arr[0]) else 0) + count_condition(arr[1:], condition_func)

# 사용 예시:
def is_even(x):
    return x % 2 == 0

def is_positive(x):
    return x > 0

def is_greater_than_5(x):
    return x > 5

]]></solution>
  </problem>

</problems>