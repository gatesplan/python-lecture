<?xml version="1.0" encoding="UTF-8"?>
<!--
  재귀함수 기본 연습 문제 - 2025.1.21 생성
  
  이 파일은 재귀함수의 기본 개념부터 중급 수준까지의 다양한 문제들을 포함합니다.
  Apprentice부터 Expert 레벨까지의 문제로 구성되어 있습니다.
  
  학습 목표:
  - 재귀함수의 기본 구조와 기저 조건 이해
  - 출력 패턴과 반복 구조의 재귀적 구현
  - 수학 알고리즘의 재귀적 접근
  - 진법 변환과 같은 실용적 문제 해결
-->
<problems>

  <!-- =========================== n개 문자 출력 =========================== -->
  
  <!-- 1. n개 문자 출력 (기본) -->
  <problem>
    <description><![CDATA[재귀함수를 사용하여 특정 문자를 n번 출력하는 함수를 작성하세요.
예: '*'를 5번 출력하면 *****]]></description>
    <code><![CDATA[def print_char_n_times(char, n):
    # 여기에 코드를 작성하세요
    pass

# 테스트
print_char_n_times('*', 5)  # ***** 가 출력되어야 합니다
print()
print_char_n_times('#', 3)  # ### 가 출력되어야 합니다]]></code>
    <input><![CDATA[char='*', n=5]]></input>
    <output><![CDATA[*****]]></output>
    <hint><![CDATA[기저 조건: n이 0 이하이면 종료합니다. 재귀 호출: 문자를 하나 출력하고 print_char_n_times(char, n-1)을 호출합니다.]]></hint>
    <solution><![CDATA[def print_char_n_times(char, n):
    # 기저 조건: n이 0 이하이면 종료
    if n <= 0:
        return
    
    # 문자 하나 출력 (줄바꿈 없이)
    print(char, end='')
    
    # 재귀 호출: n-1번 더 출력
    print_char_n_times(char, n - 1)

# 동작 과정 예시:
# print_char_n_times('*', 5)
# → print('*') → print_char_n_times('*', 4)
# → print('*') → print_char_n_times('*', 3)
# → print('*') → print_char_n_times('*', 2)
# → print('*') → print_char_n_times('*', 1)
# → print('*') → print_char_n_times('*', 0)
# → 종료
# 결과: *****]]></solution>
  </problem>

  <!-- 2. 1부터 n까지 한 줄씩 출력 -->
  <problem>
    <description><![CDATA[재귀함수를 사용하여 1부터 n까지의 숫자를 각각 한 줄씩 출력하는 함수를 작성하세요.
예: n=4일 때 1, 2, 3, 4가 각각 한 줄씩 출력]]></description>
    <code><![CDATA[def print_1_to_n(n):
    # 여기에 코드를 작성하세요
    pass

# 테스트
print("1부터 5까지:")
print_1_to_n(5)]]></code>
    <input><![CDATA[5]]></input>
    <output><![CDATA[1
2
3
4
5]]></output>
    <hint><![CDATA[기저 조건: n이 0 이하이면 종료합니다. 재귀 호출: 먼저 print_1_to_n(n-1)을 호출한 다음, n을 출력합니다.]]></hint>
    <solution><![CDATA[def print_1_to_n(n):
    # 기저 조건: n이 0 이하이면 종료
    if n <= 0:
        return
    
    # 재귀 호출: 먼저 1부터 n-1까지 출력
    print_1_to_n(n - 1)
    
    # 현재 숫자 출력
    print(n)

# 동작 과정 예시:
# print_1_to_n(4)
# → print_1_to_n(3) → print_1_to_n(2) → print_1_to_n(1) → print_1_to_n(0)
# print_1_to_n(0): 종료
# print_1_to_n(1): print(1)
# print_1_to_n(2): print(2)
# print_1_to_n(3): print(3)
# print_1_to_n(4): print(4)
# 결과: 1 2 3 4 (각각 한 줄씩)]]></solution>
  </problem>

  <!-- 3. 재귀함수 + 전역변수를 이용한 n개 문자 출력 -->
  <problem>
    <description><![CDATA[전역변수와 재귀함수를 사용하여 특정 문자를 n번 출력하는 함수를 작성하세요.
전역변수 count를 사용하여 현재까지 출력한 개수를 추적합니다.]]></description>
    <code><![CDATA[count = 0  # 전역변수

def print_char_with_global(char, n):
    global count
    # 여기에 코드를 작성하세요
    pass

def reset_count():
    global count
    count = 0

# 테스트
reset_count()
print("전역변수 사용:")
print_char_with_global('@', 4)  # @@@@ 가 출력되어야 합니다
print(f"\n총 {count}개 출력됨")]]></code>
    <input><![CDATA[char='@', n=4]]></input>
    <output><![CDATA[@@@@
총 4개 출력됨]]></output>
    <hint><![CDATA[기저 조건: count가 n과 같아지면 종료합니다. 재귀 호출: 문자를 출력하고 count를 1 증가시킨 다음, 함수를 재귀 호출합니다.]]></hint>
    <solution><![CDATA[count = 0  # 전역변수

def print_char_with_global(char, n):
    global count
    
    # 기저 조건: count가 n에 도달하면 종료
    if count >= n:
        return
    
    # 문자 출력
    print(char, end='')
    
    # 전역변수 증가
    count += 1
    
    # 재귀 호출
    print_char_with_global(char, n)

def reset_count():
    global count
    count = 0

# 동작 과정 예시:
# reset_count() → count = 0
# print_char_with_global('@', 4)
# count=0: print('@'), count=1 → 재귀 호출
# count=1: print('@'), count=2 → 재귀 호출  
# count=2: print('@'), count=3 → 재귀 호출
# count=3: print('@'), count=4 → 재귀 호출
# count=4: count >= n이므로 종료
# 결과: @@@@

# 참고: 전역변수 사용은 일반적으로 권장되지 않습니다.
# 함수의 순수성을 해치고 부작용을 일으킬 수 있기 때문입니다.]]></solution>
  </problem>

  <!-- =========================== 별 삼각형 패턴 =========================== -->

  <!-- 4. 별 삼각형 -->
  <problem>
    <description><![CDATA[재귀함수를 사용하여 별(*)로 삼각형을 출력하는 함수를 작성하세요.
n줄짜리 삼각형에서 i번째 줄에는 i개의 별을 출력합니다.]]></description>
    <code><![CDATA[def star_triangle(n):
    # 여기에 코드를 작성하세요
    pass

# 테스트
print("별 삼각형 (5줄):")
star_triangle(5)]]></code>
    <input><![CDATA[5]]></input>
    <output><![CDATA[*
**
***
****
*****]]></output>
    <hint><![CDATA[기저 조건: n이 0 이하이면 종료합니다. 재귀 호출: 먼저 star_triangle(n-1)을 호출한 다음, '*'을 n개 출력합니다.]]></hint>
    <solution><![CDATA[def star_triangle(n):
    # 기저 조건: n이 0 이하이면 종료
    if n <= 0:
        return
    
    # 재귀 호출: 먼저 n-1줄까지 출력
    star_triangle(n - 1)
    
    # 현재 줄에 n개의 별 출력
    print('*' * n)

# 동작 과정 예시:
# star_triangle(4)
# → star_triangle(3) → star_triangle(2) → star_triangle(1) → star_triangle(0)
# star_triangle(0): 종료
# star_triangle(1): print('*')      → *
# star_triangle(2): print('**')     → **  
# star_triangle(3): print('***')    → ***
# star_triangle(4): print('****')   → ****]]></solution>
  </problem>

  <!-- 5. 역별 삼각형 -->
  <problem>
    <description><![CDATA[재귀함수를 사용하여 별(*)로 역삼각형을 출력하는 함수를 작성하세요.
n줄짜리 역삼각형에서 첫 번째 줄에 n개, 마지막 줄에 1개의 별을 출력합니다.]]></description>
    <code><![CDATA[def reverse_star_triangle(n):
    # 여기에 코드를 작성하세요
    pass

# 테스트
print("역별 삼각형 (5줄):")
reverse_star_triangle(5)]]></code>
    <input><![CDATA[5]]></input>
    <output><![CDATA[*****
****
***
**
*]]></output>
    <hint><![CDATA[기저 조건: n이 0 이하이면 종료합니다. 재귀 호출: 먼저 '*'을 n개 출력한 다음, reverse_star_triangle(n-1)을 호출합니다.]]></hint>
    <solution><![CDATA[def reverse_star_triangle(n):
    # 기저 조건: n이 0 이하이면 종료
    if n <= 0:
        return
    
    # 현재 줄에 n개의 별 출력
    print('*' * n)
    
    # 재귀 호출: n-1개 별의 역삼각형 출력
    reverse_star_triangle(n - 1)

# 동작 과정 예시:
# reverse_star_triangle(4)
# print('****') → ****  → reverse_star_triangle(3)
# print('***')  → ***   → reverse_star_triangle(2)
# print('**')   → **    → reverse_star_triangle(1)
# print('*')    → *     → reverse_star_triangle(0)
# 종료]]></solution>
  </problem>

  <!-- 6. 숫자 삼각형 -->
  <problem>
    <description><![CDATA[재귀함수를 사용하여 숫자 삼각형을 출력하는 함수를 작성하세요.
i번째 줄에는 숫자 i가 i개 출력됩니다.
예: n=4일 때 1, 22, 333, 4444]]></description>
    <code><![CDATA[def number_triangle(n):
    # 여기에 코드를 작성하세요
    pass

# 테스트
print("숫자 삼각형 (5줄):")
number_triangle(5)]]></code>
    <input><![CDATA[5]]></input>
    <output><![CDATA[1
22
333
4444
55555]]></output>
    <hint><![CDATA[기저 조건: n이 0 이하이면 종료합니다. 재귀 호출: 먼저 number_triangle(n-1)을 호출한 다음, 숫자 n을 n개 출력합니다.]]></hint>
    <solution><![CDATA[def number_triangle(n):
    # 기저 조건: n이 0 이하이면 종료
    if n <= 0:
        return
    
    # 재귀 호출: 먼저 n-1줄까지 출력
    number_triangle(n - 1)
    
    # 현재 줄에 숫자 n을 n개 출력
    print(str(n) * n)

# 동작 과정 예시:
# number_triangle(4)
# → number_triangle(3) → number_triangle(2) → number_triangle(1) → number_triangle(0)
# number_triangle(0): 종료
# number_triangle(1): print('1')    → 1
# number_triangle(2): print('22')   → 22
# number_triangle(3): print('333')  → 333
# number_triangle(4): print('4444') → 4444]]></solution>
  </problem>

  <!-- 7. 숫자 역삼각형 -->
  <problem>
    <description><![CDATA[재귀함수를 사용하여 숫자 역삼각형을 출력하는 함수를 작성하세요.
첫 번째 줄에 숫자 n을 n개, 마지막 줄에 숫자 1을 1개 출력합니다.
예: n=4일 때 4444, 333, 22, 1]]></description>
    <code><![CDATA[def reverse_number_triangle(n):
    # 여기에 코드를 작성하세요
    pass

# 테스트
print("숫자 역삼각형 (5줄):")
reverse_number_triangle(5)]]></code>
    <input><![CDATA[5]]></input>
    <output><![CDATA[55555
4444
333
22
1]]></output>
    <hint><![CDATA[기저 조건: n이 0 이하이면 종료합니다. 재귀 호출: 먼저 숫자 n을 n개 출력한 다음, reverse_number_triangle(n-1)을 호출합니다.]]></hint>
    <solution><![CDATA[def reverse_number_triangle(n):
    # 기저 조건: n이 0 이하이면 종료
    if n <= 0:
        return
    
    # 현재 줄에 숫자 n을 n개 출력
    print(str(n) * n)
    
    # 재귀 호출: n-1부터의 역삼각형 출력
    reverse_number_triangle(n - 1)

# 동작 과정 예시:
# reverse_number_triangle(4)
# print('4444') → 4444 → reverse_number_triangle(3)
# print('333')  → 333  → reverse_number_triangle(2)
# print('22')   → 22   → reverse_number_triangle(1)
# print('1')    → 1    → reverse_number_triangle(0)
# 종료]]></solution>
  </problem>

  <!-- =========================== 수학 알고리즘 =========================== -->

  <!-- 8. 최대공약수 (유클리드 호제법) -->
  <problem>
    <description><![CDATA[재귀함수를 사용하여 두 양의 정수의 최대공약수를 구하는 함수를 작성하세요. (유클리드 호제법)
유클리드 호제법: gcd(a, b) = gcd(b, a mod b), gcd(a, 0) = a]]></description>
    <code><![CDATA[def gcd(a, b):
    # 여기에 코드를 작성하세요
    pass

# 테스트
print(f"gcd(48, 18) = {gcd(48, 18)}")   # 6이 나와야 합니다
print(f"gcd(56, 42) = {gcd(56, 42)}")   # 14가 나와야 합니다
print(f"gcd(17, 13) = {gcd(17, 13)}")   # 1이 나와야 합니다]]></code>
    <input><![CDATA[a=48, b=18]]></input>
    <output><![CDATA[6]]></output>
    <hint><![CDATA[기저 조건: b가 0이면 a를 반환합니다. 재귀 호출: gcd(b, a % b)를 반환합니다.]]></hint>
    <solution><![CDATA[def gcd(a, b):
    # 기저 조건: b가 0이면 a가 최대공약수
    if b == 0:
        return a
    
    # 재귀 호출: 유클리드 호제법 적용
    return gcd(b, a % b)

# 동작 과정 예시:
# gcd(48, 18) = gcd(18, 48 % 18) = gcd(18, 12)
#             = gcd(12, 18 % 12) = gcd(12, 6)
#             = gcd(6, 12 % 6)   = gcd(6, 0)
#             = 6

# 유클리드 호제법의 원리:
# 두 수 a, b의 최대공약수는 
# b와 a를 b로 나눈 나머지의 최대공약수와 같습니다.
# 이 과정을 나머지가 0이 될 때까지 반복하면
# 마지막에 남은 수가 최대공약수입니다.]]></solution>
  </problem>

  <!-- 9. 최소공배수 -->
  <problem>
    <description><![CDATA[재귀함수를 사용하여 두 양의 정수의 최소공배수를 구하는 함수를 작성하세요.
최소공배수 공식: lcm(a, b) = (a × b) / gcd(a, b)
앞에서 구현한 gcd 함수를 활용하세요.]]></description>
    <code><![CDATA[def gcd(a, b):
    # 앞에서 구현한 최대공약수 함수
    if b == 0:
        return a
    return gcd(b, a % b)

def lcm(a, b):
    # 여기에 코드를 작성하세요
    pass

# 테스트
print(f"lcm(12, 18) = {lcm(12, 18)}")   # 36이 나와야 합니다
print(f"lcm(15, 25) = {lcm(15, 25)}")   # 75가 나와야 합니다
print(f"lcm(7, 11) = {lcm(7, 11)}")     # 77이 나와야 합니다]]></code>
    <input><![CDATA[a=12, b=18]]></input>
    <output><![CDATA[36]]></output>
    <hint><![CDATA[최소공배수는 (a × b) / gcd(a, b) 공식을 사용합니다. gcd 함수를 호출해서 최대공약수를 구한 다음 계산하세요.]]></hint>
    <solution><![CDATA[def gcd(a, b):
    # 앞에서 구현한 최대공약수 함수
    if b == 0:
        return a
    return gcd(b, a % b)

def lcm(a, b):
    # 최소공배수 공식: lcm(a, b) = (a × b) / gcd(a, b)
    return (a * b) // gcd(a, b)

# 동작 과정 예시:
# lcm(12, 18)
# gcd(12, 18) = 6
# lcm = (12 × 18) / 6 = 216 / 6 = 36

# 최소공배수의 성질:
# - 두 수의 곱을 최대공약수로 나눈 값
# - 두 수 모두의 배수 중 가장 작은 양의 정수
# - gcd(a, b) × lcm(a, b) = a × b

# 검증:
# 12의 배수: 12, 24, 36, 48, ...
# 18의 배수: 18, 36, 54, 72, ...
# 공통 배수: 36, 72, 108, ...
# 최소공배수: 36]]></solution>
  </problem>

  <!-- =========================== 진법 변환 =========================== -->

  <!-- 10. 10진수를 2진수로 변환 -->
  <problem>
    <description><![CDATA[재귀함수를 사용하여 10진수를 2진수 문자열로 변환하는 함수를 작성하세요.
예: 10 → "1010", 7 → "111"]]></description>
    <code><![CDATA[def decimal_to_binary(n):
    # 여기에 코드를 작성하세요
    pass

# 테스트
print(f"decimal_to_binary(10) = {decimal_to_binary(10)}")  # "1010"
print(f"decimal_to_binary(7) = {decimal_to_binary(7)}")    # "111"
print(f"decimal_to_binary(0) = {decimal_to_binary(0)}")    # "0"
print(f"decimal_to_binary(1) = {decimal_to_binary(1)}")    # "1"]]></code>
    <input><![CDATA[10]]></input>
    <output><![CDATA["1010"]]></output>
    <hint><![CDATA[기저 조건: n이 0이면 빈 문자열을, n이 1이면 "1"을 반환합니다. 재귀 호출: decimal_to_binary(n//2) + str(n%2)를 반환합니다.]]></hint>
    <solution><![CDATA[def decimal_to_binary(n):
    # 기저 조건: n이 0이면 "0" 반환 (특별한 경우)
    if n == 0:
        return "0"
    
    # 기저 조건: n이 1이면 "1" 반환
    if n == 1:
        return "1"
    
    # 재귀 호출: 몫의 2진수 + 나머지
    return decimal_to_binary(n // 2) + str(n % 2)

# 동작 과정 예시:
# decimal_to_binary(10)
# = decimal_to_binary(10//2) + str(10%2)
# = decimal_to_binary(5) + "0"
# = (decimal_to_binary(5//2) + str(5%2)) + "0"
# = (decimal_to_binary(2) + "1") + "0"
# = ((decimal_to_binary(2//2) + str(2%2)) + "1") + "0"
# = ((decimal_to_binary(1) + "0") + "1") + "0"
# = (("1" + "0") + "1") + "0"
# = ("10" + "1") + "0"
# = "101" + "0"
# = "1010"

# 진법 변환 원리:
# 10진수를 2진수로 변환하려면
# 계속 2로 나누면서 나머지를 역순으로 연결]]></solution>
  </problem>

  <!-- 11. 10진수를 n진수로 변환 -->
  <problem>
    <description><![CDATA[재귀함수를 사용하여 10진수를 임의의 n진수 문자열로 변환하는 함수를 작성하세요.
2진수부터 16진수까지 지원하며, 10 이상의 숫자는 A, B, C, D, E, F로 표현합니다.
예: decimal_to_base(255, 16) → "FF"]]></description>
    <code><![CDATA[def decimal_to_base(n, base):
    # 여기에 코드를 작성하세요
    pass

# 테스트
print(f"decimal_to_base(10, 2) = {decimal_to_base(10, 2)}")    # "1010"
print(f"decimal_to_base(255, 16) = {decimal_to_base(255, 16)}")  # "FF"
print(f"decimal_to_base(100, 8) = {decimal_to_base(100, 8)}")   # "144"
print(f"decimal_to_base(15, 16) = {decimal_to_base(15, 16)}")   # "F"]]></code>
    <input><![CDATA[n=255, base=16]]></input>
    <output><![CDATA["FF"]]></output>
    <hint><![CDATA[기저 조건: n이 0이면 "0"을, n < base이면 해당 자릿값을 반환합니다. 10 이상의 값은 'A', 'B' 등으로 변환해야 합니다. 재귀 호출: decimal_to_base(n//base, base) + 나머지에 해당하는 문자를 반환합니다.]]></hint>
    <solution><![CDATA[def decimal_to_base(n, base):
    # 기저 조건: n이 0이면 "0" 반환
    if n == 0:
        return "0"
    
    # 기저 조건: n이 base보다 작으면 해당 문자 반환
    if n < base:
        if n < 10:
            return str(n)
        else:
            # 10, 11, 12, 13, 14, 15를 A, B, C, D, E, F로 변환
            return chr(ord('A') + n - 10)
    
    # 나머지를 문자로 변환
    remainder = n % base
    if remainder < 10:
        remainder_char = str(remainder)
    else:
        remainder_char = chr(ord('A') + remainder - 10)
    
    # 재귀 호출: 몫의 base진수 + 나머지 문자
    return decimal_to_base(n // base, base) + remainder_char

# 동작 과정 예시:
# decimal_to_base(255, 16)
# = decimal_to_base(255//16, 16) + 'F'  (255%16=15 → 'F')
# = decimal_to_base(15, 16) + 'F'
# = "F" + "F"  (15는 base보다 작으므로 기저 조건, 15 → 'F')
# = "FF"

# decimal_to_base(100, 8)
# = decimal_to_base(100//8, 8) + '4'  (100%8=4 → '4')
# = decimal_to_base(12, 8) + '4'
# = (decimal_to_base(12//8, 8) + '4') + '4'  (12%8=4 → '4')
# = (decimal_to_base(1, 8) + '4') + '4'
# = ("1" + "4") + "4"  (1은 base보다 작음)
# = "14" + "4"
# = "144"

# 진법 변환의 일반 원리:
# n진법으로 변환하려면 계속 n으로 나누면서
# 나머지를 역순으로 연결하면 됩니다.]]></solution>
  </problem>

  <!-- 12. n진수를 10진수로 변환 -->
  <problem>
    <description><![CDATA[재귀함수를 사용하여 n진수 문자열을 10진수로 변환하는 함수를 작성하세요.
2진수부터 16진수까지 지원하며, A, B, C, D, E, F는 10, 11, 12, 13, 14, 15를 의미합니다.
예: base_to_decimal("FF", 16) → 255]]></description>
    <code><![CDATA[def base_to_decimal(s, base):
    # 여기에 코드를 작성하세요
    pass

# 테스트
print(f"base_to_decimal('1010', 2) = {base_to_decimal('1010', 2)}")    # 10
print(f"base_to_decimal('FF', 16) = {base_to_decimal('FF', 16)}")      # 255
print(f"base_to_decimal('144', 8) = {base_to_decimal('144', 8)}")      # 100
print(f"base_to_decimal('F', 16) = {base_to_decimal('F', 16)}")        # 15]]></code>
    <input><![CDATA[s="FF", base=16]]></input>
    <output><![CDATA[255]]></output>
    <hint><![CDATA[기저 조건: 문자열이 비어있으면 0을 반환합니다. 재귀 호출: 마지막 문자의 값 + (나머지 문자열의 변환 결과 × base)를 반환합니다. A-F는 10-15로 변환해야 합니다.]]></hint>
    <solution><![CDATA[def base_to_decimal(s, base):
    # 기저 조건: 빈 문자열이면 0 반환
    if not s:
        return 0
    
    # 마지막 문자를 숫자로 변환
    last_char = s[-1]
    if last_char.isdigit():
        last_digit = int(last_char)
    else:
        # A, B, C, D, E, F를 10, 11, 12, 13, 14, 15로 변환
        last_digit = ord(last_char.upper()) - ord('A') + 10
    
    # 재귀 호출: 나머지 부분의 값 × base + 마지막 자릿수
    remaining = base_to_decimal(s[:-1], base)
    
    return remaining * base + last_digit

# 동작 과정 예시:
# base_to_decimal("FF", 16)
# last_char = 'F' → last_digit = 15
# remaining = base_to_decimal("F", 16)
#   last_char = 'F' → last_digit = 15
#   remaining = base_to_decimal("", 16) = 0
#   result = 0 × 16 + 15 = 15
# result = 15 × 16 + 15 = 240 + 15 = 255

# base_to_decimal("1010", 2)
# last_char = '0' → last_digit = 0
# remaining = base_to_decimal("101", 2)
#   last_char = '1' → last_digit = 1
#   remaining = base_to_decimal("10", 2)
#     last_char = '0' → last_digit = 0
#     remaining = base_to_decimal("1", 2)
#       last_char = '1' → last_digit = 1
#       remaining = base_to_decimal("", 2) = 0
#       result = 0 × 2 + 1 = 1
#     result = 1 × 2 + 0 = 2
#   result = 2 × 2 + 1 = 5
# result = 5 × 2 + 0 = 10

# n진법에서 10진법 변환 원리:
# 가장 오른쪽(낮은 자릿수)부터 처리하여
# 이전 결과에 base를 곱하고 현재 자릿값을 더함]]></solution>
  </problem>

</problems>