<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: 출력 예측 (팩토리얼) - 워밍업 -->
  <problem>
    <description>다음 코드의 출력 결과를 쓰세요.</description>
    <code><![CDATA[def f(n):
    if n <= 1:
        return 1
    return n * f(n-1)

print(f(4))
print(f(5))]]></code>
    <input></input>
    <output><![CDATA[24
120]]></output>
    <solution><![CDATA[# f(4) = 4 * f(3)
#      = 4 * 3 * f(2)
#      = 4 * 3 * 2 * f(1)
#      = 4 * 3 * 2 * 1
#      = 24
#
# f(5) = 5 * 4 * 3 * 2 * 1 = 120
#
# 정답: 24, 120]]></solution>
  </problem>

  <!-- 문제 2: 빈칸 채우기 (기저 조건) -->
  <problem>
    <description>팩토리얼을 구하는 재귀함수입니다. 기저 조건을 완성하세요.</description>
    <code><![CDATA[def f(n):
    if ____:
        return 1
    return n * f(n-1)]]></code>
    <input><![CDATA[print(f(5))
print(f(3))]]></input>
    <output><![CDATA[120
6]]></output>
    <solution><![CDATA[def f(n):
    if n <= 1:  # 정답: n <= 1 또는 n == 0 또는 n == 1
        return 1
    return n * f(n-1)

# 기저 조건: 재귀를 멈추는 조건
# n이 1 이하일 때 1을 반환하여 재귀 종료]]></solution>
  </problem>

  <!-- 문제 3: 빈칸 채우기 (재귀 호출) -->
  <problem>
    <description>거듭제곱을 구하는 재귀함수입니다. return 부분을 완성하세요. (base^exp 계산)</description>
    <code><![CDATA[def f(base, exp):
    if exp == 0:
        return 1
    return ____]]></code>
    <input><![CDATA[print(f(2, 3))
print(f(3, 4))]]></input>
    <output><![CDATA[8
81]]></output>
    <solution><![CDATA[def f(base, exp):
    if exp == 0:
        return 1
    return base * f(base, exp-1)  # 정답: base * f(base, exp-1)

# 재귀 관계: base^exp = base * base^(exp-1)
# 예: 2^3 = 2 * 2^2 = 2 * 2 * 2^1 = 2 * 2 * 2 * 2^0 = 8]]></solution>
  </problem>

  <!-- 문제 4: 디버깅 (무한 재귀 오류) -->
  <problem>
    <description>다음 팩토리얼 함수는 무한 재귀에 빠집니다. 오류를 찾아 고치세요.</description>
    <code><![CDATA[def f(n):
    if n == 1:
        return 1
    return n * f(n)]]></code>
    <input><![CDATA[print(f(5))]]></input>
    <output><![CDATA[120]]></output>
    <solution><![CDATA[def f(n):
    if n == 1:
        return 1
    return n * f(n-1)  # 오류: f(n)이 아니라 f(n-1)이어야 함

# 잘못된 부분: f(n) → f(n-1)
# 이유: n을 감소시키지 않으면 무한 재귀
# f(5)는 계속 f(5)를 호출하여 기저 조건에 도달하지 못함]]></solution>
  </problem>

  <!-- 문제 5: 전체 작성 (팩토리얼) -->
  <problem>
    <description>주어진 수 n의 팩토리얼을 재귀함수로 구현하세요. (n! = n × (n-1) × ... × 1)</description>
    <code><![CDATA[def f(n):
    pass]]></code>
    <input><![CDATA[print(f(6))
print(f(4))
print(f(1))]]></input>
    <output><![CDATA[720
24
1]]></output>
    <solution><![CDATA[def f(n):
    # 기저 조건: n이 1 이하면 1 반환
    if n <= 1:
        return 1
    # 재귀: n × (n-1)!
    return n * f(n-1)

# 실행 예시: f(4)
# f(4) = 4 * f(3)
#      = 4 * 3 * f(2)
#      = 4 * 3 * 2 * f(1)
#      = 4 * 3 * 2 * 1 = 24]]></solution>
  </problem>

  <!-- 문제 6: 트레이싱 (거듭제곱 호출 횟수) -->
  <problem>
    <description>다음 거듭제곱 재귀 함수에서 f(2, 4)를 실행할 때, f 함수가 총 몇 번 호출되는지 구하세요.</description>
    <code><![CDATA[def f(base, exp):
    if exp == 0:
        return 1
    return base * f(base, exp-1)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# f(2, 4) 호출 추적:
# f(2, 4) = 2 * f(2, 3)
#   f(2, 3) = 2 * f(2, 2)
#     f(2, 2) = 2 * f(2, 1)
#       f(2, 1) = 2 * f(2, 0)
#         f(2, 0) = 1 (기저 조건)
#
# 총 호출: f(2,4), f(2,3), f(2,2), f(2,1), f(2,0) = 5번
# 정답: 5번]]></solution>
  </problem>

  <!-- 문제 7: 빈칸 채우기 (배열 합) -->
  <problem>
    <description>배열의 모든 원소의 합을 재귀로 구하는 함수입니다. 빈칸을 채우세요.</description>
    <code><![CDATA[def f(arr, n):
    if n == 0:
        return 0
    return ____ + f(arr, n-1)]]></code>
    <input><![CDATA[print(f([1, 2, 3, 4], 4))
print(f([5, 10, 15], 3))]]></input>
    <output><![CDATA[10
30]]></output>
    <solution><![CDATA[def f(arr, n):
    if n == 0:
        return 0
    return arr[n-1] + f(arr, n-1)  # 정답: arr[n-1] + f(arr, n-1)

# arr[n-1]: 현재 위치의 원소
# f(arr, n-1): 나머지 원소들의 합
# 재귀 관계: sum(arr[0..n-1]) = arr[n-1] + sum(arr[0..n-2])]]></solution>
  </problem>

  <!-- 문제 8: 전체 작성 (배열 최댓값) -->
  <problem>
    <description>배열의 최댓값을 재귀로 구하는 함수를 작성하세요. n은 배열의 크기입니다.</description>
    <code><![CDATA[def f(arr, n):
    pass]]></code>
    <input><![CDATA[print(f([3, 1, 4, 1, 5], 5))
print(f([10, 20, 5], 3))]]></input>
    <output><![CDATA[5
20]]></output>
    <solution><![CDATA[def f(arr, n):
    # 기저 조건: 원소가 1개면 그 값 반환
    if n == 1:
        return arr[0]
    # 재귀: 현재 원소와 나머지 중 최댓값 비교
    return max(arr[n-1], f(arr, n-1))

# 실행 예시: f([3, 1, 4, 1, 5], 5)
# max(5, f([3,1,4,1], 4))
#   = max(5, max(1, f([3,1,4], 3)))
#     = max(5, max(1, max(4, f([3,1], 2))))
#       = max(5, max(1, max(4, max(1, 3))))
#       = max(5, max(1, max(4, 3)))
#       = max(5, max(1, 4))
#       = max(5, 4) = 5]]></solution>
  </problem>

  <!-- 문제 9: 디버깅 (기저 조건 누락) -->
  <problem>
    <description>다음 배열 합 재귀 함수에 오류가 있습니다. 오류를 찾아 고치세요.</description>
    <code><![CDATA[def f(arr, n):
    return arr[n-1] + f(arr, n-1)]]></code>
    <input><![CDATA[print(f([1, 2, 3], 3))]]></input>
    <output><![CDATA[6]]></output>
    <solution><![CDATA[def f(arr, n):
    if n == 0:  # 오류: 기저 조건이 없어서 무한 재귀 발생
        return 0
    return arr[n-1] + f(arr, n-1)

# 잘못된 부분: 기저 조건 누락
# 이유: n이 0이 될 때까지 계속 재귀하는데 멈출 조건이 없음
# n이 0이 되면 arr[-1]을 참조하여 오류 발생
# 기저 조건을 추가하여 n==0일 때 0 반환]]></solution>
  </problem>

  <!-- 문제 10: 블록 채우기 (재귀/반복 변환) -->
  <problem>
    <description>재귀로 작성된 팩토리얼 함수를 for문으로 변환하세요. for문 블록 내부를 완성하세요.</description>
    <code><![CDATA[def f(n):
    result = 1
    for i in range(1, n+1):
        # 여기를 채우세요
    return result]]></code>
    <input><![CDATA[print(f(5))
print(f(4))]]></input>
    <output><![CDATA[120
24]]></output>
    <solution><![CDATA[def f(n):
    result = 1
    for i in range(1, n+1):
        # i를 result에 곱함
        result = result * i
        # 또는: result *= i
    return result

# 재귀 버전: f(n) = n * f(n-1)
# 반복 버전: result = 1 * 2 * 3 * ... * n
# 1부터 n까지 순차적으로 곱함]]></solution>
  </problem>
</problems>
