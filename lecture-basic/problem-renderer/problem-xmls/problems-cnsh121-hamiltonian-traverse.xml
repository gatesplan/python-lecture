<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: 종료 조건 완성 -->
  <problem>
    <description>다음 해밀턴 경로 탐색 함수에서 16번라인의 종료 조건을 완성하세요.</description>
    <code><![CDATA[V, E = map(int, input().split())
M = [[] for i in range(V)]
visited = [0]*V
ok = False

for i in range(E):
    u, v = map(int, input().split())
    M[u].append(v)
    M[v].append(u)

def f(x, y, z):
    global V, visited, ok, M

    if ok: return

    if ____:  # 여기를 채우세요
        ok = True
        for i in z:
            print(i, end=' ')
        return

    visited[x] = True

    for u in M[x]:
        if not visited[u]:
            z.append(u)
            f(u, y+1, z)
            z.pop()

    visited[x] = False
    return]]></code>
    <input><![CDATA[f(0, 1, [0])]]></input>
    <output></output>
    <hint></hint>
    <solution><![CDATA[if y == V:  # 정답: y == V
# 이유: y는 현재까지 방문한 정점의 개수
# V는 전체 정점의 개수
# y == V이면 모든 정점을 방문했으므로 해밀턴 경로 완성]]></solution>
  </problem>

  <!-- 문제 2: 방문 표시 완성 -->
  <problem>
    <description>다음 해밀턴 경로 탐색 함수에서 22번라인의 방문 표시를 완성하세요.</description>
    <code><![CDATA[def f(x, y, z):
    global V, visited, ok, M

    if ok: return

    if y == V:
        ok = True
        for i in z:
            print(i, end=' ')
        return

    visited[x] = ____  # 여기를 채우세요

    for u in M[x]:
        if not visited[u]:
            z.append(u)
            f(u, y+1, z)
            z.pop()

    visited[x] = False
    return]]></code>
    <input><![CDATA[]]></input>
    <output></output>
    <hint></hint>
    <solution><![CDATA[visited[x] = True  # 정답: True
# 이유: 현재 정점 x를 방문했다고 표시
# 백트래킹에서 방문한 정점을 다시 방문하지 않도록 함]]></solution>
  </problem>

  <!-- 문제 3: 재귀 호출 파라메터 완성 -->
  <problem>
    <description>다음 해밀턴 경로 탐색 함수에서 27번라인의 재귀 호출 파라메터를 완성하세요.</description>
    <code><![CDATA[def f(x, y, z):
    global V, visited, ok, M

    if ok: return

    if y == V:
        ok = True
        for i in z:
            print(i, end=' ')
        return

    visited[x] = True

    for u in M[x]:
        if not visited[u]:
            z.append(u)
            f(____, ____, ____)  # 여기를 채우세요
            z.pop()

    visited[x] = False
    return]]></code>
    <input><![CDATA[]]></input>
    <output></output>
    <hint></hint>
    <solution><![CDATA[f(u, y+1, z)  # 정답: u, y+1, z
# u: 다음 방문할 정점 (현재 정점 x에서 갈 수 있는 인접 정점)
# y+1: 방문한 정점 개수를 하나 증가 (u를 방문하므로)
# z: 현재까지의 경로 리스트 (이미 z.append(u)로 u가 추가됨)]]></solution>
  </problem>

  <!-- 문제 4: 파라메터 역할 설명 -->
  <problem>
    <description>해밀턴 경로 탐색 함수 f(x, y, z)에서 각 파라메터 x, y, z의 역할에 대해 설명하세요.</description>
    <code><![CDATA[def f(x, y, z):
    global V, visited, ok, M

    if ok: return

    if y == V:
        ok = True
        for i in z:
            print(i, end=' ')
        return

    visited[x] = True

    for u in M[x]:
        if not visited[u]:
            z.append(u)
            f(u, y+1, z)
            z.pop()

    visited[x] = False
    return]]></code>
    <input><![CDATA[]]></input>
    <output></output>
    <hint></hint>
    <solution><![CDATA[# 각 파라메터의 역할:

# x: 현재 방문 중인 정점 번호
#    - 이 정점에서 인접한 다른 정점들을 탐색함
#    - 백트래킹의 현재 위치를 나타냄

# y: 현재까지 방문한 정점의 개수
#    - 해밀턴 경로 완성 여부 판단에 사용 (y == V이면 완성)
#    - 재귀 깊이를 나타내기도 함

# z: 현재까지의 경로를 저장하는 리스트
#    - 지금까지 방문한 정점들의 순서를 기록
#    - 해밀턴 경로 완성 시 이 리스트가 최종 경로가 됨
#    - 백트래킹 시 append/pop으로 경로를 동적으로 관리]]></solution>
  </problem>

  <!-- 문제 5: 실행 결과 예측 -->
  <problem>
    <description>다음 그래프 입력에서 f(3, 1, [3])을 실행했을 때의 출력 결과를 구하세요.</description>
    <code><![CDATA[V, E = map(int, input().split())
M = [[] for i in range(V)]
visited = [0]*V
ok = False

for i in range(E):
    u, v = map(int, input().split())
    M[u].append(v)
    M[v].append(u)

def f(x, y, z):
    global V, visited, ok, M

    if ok: return

    if y == V:
        ok = True
        for i in z:
            print(i, end=' ')
        return

    visited[x] = True

    for u in M[x]:
        if not visited[u]:
            z.append(u)
            f(u, y+1, z)
            z.pop()

    visited[x] = False
    return]]></code>
    <input><![CDATA[7 11
0 1
0 2
0 3
0 6
1 2
2 6
3 4
3 5
3 6
4 5
5 6
f(3, 1, [3])]]></input>
    <output><![CDATA[3 0 1 2 6 5 4 ]]></output>
    <hint></hint>
    <solution><![CDATA[# 그래프 구조:
# 정점: 0, 1, 2, 3, 4, 5, 6 (총 7개)
# 간선: 0-1, 0-2, 0-3, 0-6, 1-2, 2-6, 3-4, 3-5, 3-6, 4-5, 5-6

# f(3, 1, [3]) 실행 과정:
# 시작점 3에서 모든 정점을 방문하는 해밀턴 경로 탐색
# 정점 3에서 연결된 정점들: 0, 4, 5, 6
# 백트래킹을 통해 가능한 경로 중 첫 번째로 찾은 경로:
# 3 → 0 → 1 → 2 → 6 → 5 → 4

# 출력: 3 0 1 2 6 5 4 (공백으로 구분)]]></solution>
  </problem>
</problems>