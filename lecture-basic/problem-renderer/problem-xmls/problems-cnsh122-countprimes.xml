<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: for j 내부 블럭 작성 -->
  <problem>
    <description>다음 코드는 2부터 n까지의 수 중 소수의 개수를 세는 코드입니다. for j 반복문 내부 블럭을 완성하세요.</description>
    <code><![CDATA[ans = 0
n = 1000

for i in range(2, n+1):
    cnt = 0
    for j in range(2, i):
        # 여기를 채우세요

    if cnt == 0:
        ans += 1

print(ans)]]></code>
    <input></input>
    <output><![CDATA[168]]></output>
    <solution><![CDATA[ans = 0
n = 1000

for i in range(2, n+1):
    cnt = 0
    for j in range(2, i):
        if (i%j) == 0:
            cnt = cnt + 1

    if cnt == 0:
        ans += 1

print(ans)]]></solution>
  </problem>

  <!-- 문제 2: if cnt == 0 내부 블럭 작성 -->
  <problem>
    <description>다음 코드는 2부터 n까지의 수 중 소수의 개수를 세는 코드입니다. if cnt == 0 블럭 내부를 완성하세요.</description>
    <code><![CDATA[ans = 0
n = 1000

for i in range(2, n+1):
    cnt = 0
    for j in range(2, i):
        if (i%j) == 0:
            cnt = cnt + 1

    if cnt == 0:
        # 여기를 채우세요

print(ans)]]></code>
    <input></input>
    <output><![CDATA[168]]></output>
    <solution><![CDATA[ans = 0
n = 1000

for i in range(2, n+1):
    cnt = 0
    for j in range(2, i):
        if (i%j) == 0:
            cnt = cnt + 1

    if cnt == 0:
        ans += 1  # 또는 ans = ans + 1

print(ans)]]></solution>
  </problem>

  <!-- 문제 3: for i 내부 블럭 작성 -->
  <problem>
    <description>다음 코드는 2부터 n까지의 수 중 소수의 개수를 세는 코드입니다. for i 반복문 내부 블럭을 완성하세요.</description>
    <code><![CDATA[ans = 0
n = 1000

for i in range(2, n+1):
    # 여기를 채우세요

print(ans)]]></code>
    <input></input>
    <output><![CDATA[168]]></output>
    <solution><![CDATA[ans = 0
n = 1000

for i in range(2, n+1):
    cnt = 0
    for j in range(2, i):
        if (i%j) == 0:
            cnt = cnt + 1

    if cnt == 0:
        ans += 1

print(ans)]]></solution>
  </problem>

  <!-- 문제 4: 효율성 개선 버전 빈칸 채우기 -->
  <problem>
    <description>다음 코드는 2부터 n까지의 수 중 소수의 개수를 세는 효율적인 코드입니다. 빈칸을 채우세요.</description>
    <code><![CDATA[ans = 0
n = 1000

for i in range(2, n+1):
    cnt = 0
    for j in range(2, ____):  # 여기를 채우세요
        if (i%j) == 0:
            ____  # 여기를 채우세요
            break

    if ____:  # 여기를 채우세요
        ans += 1

print(ans)]]></code>
    <input></input>
    <output><![CDATA[168]]></output>
    <solution><![CDATA[ans = 0
n = 1000

for i in range(2, n+1):
    cnt = 0
    for j in range(2, int(i**0.5)+1):  # 정답: int(i**0.5)+1
        if (i%j) == 0:
            cnt = cnt + 1  # 정답: cnt = cnt + 1 또는 cnt += 1
            break

    if cnt == 0:  # 정답: cnt == 0
        ans += 1

print(ans)]]></solution>
  </problem>

  <!-- 문제 5: 원본 개선하고 변경사항 서술 -->
  <problem>
    <description>다음 원본 코드를 효율성 개선하여 작성하고, 어떤 변경을 했는지 서술하세요.</description>
    <code><![CDATA[ans = 0
n = 1000

for i in range(2, n+1):
    cnt = 0
    for j in range(2, i):
        if (i%j) == 0:
            cnt = cnt + 1

    if cnt == 0:
        ans += 1

print(ans)

# 개선 버전
# 여기를 채우세요]]></code>
    <input></input>
    <output><![CDATA[168]]></output>
    <solution><![CDATA[# 개선 버전
ans = 0
n = 1000

for i in range(2, n+1):
    cnt = 0
    for j in range(2, int(i**0.5)+1):
        if (i%j) == 0:
            cnt = cnt + 1
            break

    if cnt == 0:
        ans += 1

print(ans)

# 변경 사항 (상태 공간 배제):
# 1. range 개선: range(2, i) → range(2, int(i**0.5)+1)
#    - 제곱근까지만 확인 (약수의 대칭성 이용)
#    - 탐색 범위 자체를 축소
# 2. break 추가: 약수 발견 즉시 반복 중단
#    - 나머지 불필요한 탐색 건너뜀]]></solution>
  </problem>
</problems>
