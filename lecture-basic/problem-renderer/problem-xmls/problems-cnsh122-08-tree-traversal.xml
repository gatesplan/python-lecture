<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: 출력 예측 (전위 순회 결과) - 워밍업 -->
  <problem>
    <description>다음 전위 순회 코드의 출력 결과를 쓰세요.</description>
    <code><![CDATA[T = [1, 2, 3, 4, 5, 6, 7]

def f(i):
    if i >= len(T):
        return
    print(T[i], end=' ')
    f(2*i + 1)
    f(2*i + 2)

f(0)]]></code>
    <input></input>
    <output><![CDATA[1 2 4 5 3 6 7]]></output>
    <solution><![CDATA[# 전위 순회 (Preorder): 부모 → 왼쪽 → 오른쪽
# 트리 구조:
#       1
#      / \
#     2   3
#    / \ / \
#   4  5 6  7
#
# 순회 순서:
# 1 (루트) → 2 (왼쪽 서브트리) → 4 → 5 → 3 (오른쪽 서브트리) → 6 → 7
#
# 정답: 1 2 4 5 3 6 7]]></solution>
  </problem>

  <!-- 문제 2: 출력 예측 (중위 순회 결과) -->
  <problem>
    <description>다음 중위 순회 코드의 출력 결과를 쓰세요.</description>
    <code><![CDATA[T = [1, 2, 3, 4, 5, 6, 7]

def f(i):
    if i >= len(T):
        return
    f(2*i + 1)
    print(T[i], end=' ')
    f(2*i + 2)

f(0)]]></code>
    <input></input>
    <output><![CDATA[4 2 5 1 6 3 7]]></output>
    <solution><![CDATA[# 중위 순회 (Inorder): 왼쪽 → 부모 → 오른쪽
# 트리 구조:
#       1
#      / \
#     2   3
#    / \ / \
#   4  5 6  7
#
# 순회 순서:
# 4 (왼쪽 끝) → 2 → 5 → 1 (루트) → 6 → 3 → 7 (오른쪽 끝)
#
# 특징: BST에서 중위 순회는 오름차순 정렬 결과
#
# 정답: 4 2 5 1 6 3 7]]></solution>
  </problem>

  <!-- 문제 3: 출력 예측 (후위 순회 결과) -->
  <problem>
    <description>다음 후위 순회 코드의 출력 결과를 쓰세요.</description>
    <code><![CDATA[T = [1, 2, 3, 4, 5, 6, 7]

def f(i):
    if i >= len(T):
        return
    f(2*i + 1)
    f(2*i + 2)
    print(T[i], end=' ')

f(0)]]></code>
    <input></input>
    <output><![CDATA[4 5 2 6 7 3 1]]></output>
    <solution><![CDATA[# 후위 순회 (Postorder): 왼쪽 → 오른쪽 → 부모
# 트리 구조:
#       1
#      / \
#     2   3
#    / \ / \
#   4  5 6  7
#
# 순회 순서:
# 4 → 5 → 2 (왼쪽 서브트리 완료) → 6 → 7 → 3 (오른쪽 서브트리 완료) → 1 (루트)
#
# 특징: 자식들을 모두 방문한 후 부모 방문
#
# 정답: 4 5 2 6 7 3 1]]></solution>
  </problem>

  <!-- 문제 4: 서술형 (부모-자식 인덱스 공식) -->
  <problem>
    <description>배열로 표현된 이진 트리에서 부모 인덱스 i가 주어졌을 때, 왼쪽 자식과 오른쪽 자식의 인덱스를 구하는 공식을 쓰고, 자식 인덱스 i에서 부모 인덱스를 구하는 공식을 쓰세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 배열로 표현된 이진 트리의 인덱스 관계
#
# 부모 인덱스 i가 주어졌을 때:
# - 왼쪽 자식 인덱스: 2*i + 1
# - 오른쪽 자식 인덱스: 2*i + 2
#
# 자식 인덱스 i가 주어졌을 때:
# - 부모 인덱스: (i - 1) // 2
#
# 예시 (0-based indexing):
# 배열: [1, 2, 3, 4, 5, 6, 7]
#        0  1  2  3  4  5  6
#
# 인덱스 1(값 2)의 자식:
# - 왼쪽: 2*1+1 = 3 (값 4)
# - 오른쪽: 2*1+2 = 4 (값 5)
#
# 인덱스 5(값 6)의 부모:
# - (5-1)//2 = 2 (값 3)
#
# 참고: 1-based indexing에서는 다름
# - 왼쪽 자식: 2*i
# - 오른쪽 자식: 2*i + 1
# - 부모: i // 2]]></solution>
  </problem>

  <!-- 문제 5: 빈칸 채우기 (전위 순회 print 위치) -->
  <problem>
    <description>전위 순회를 구현하는 코드입니다. 빈칸을 채우세요.</description>
    <code><![CDATA[T = [10, 20, 30, 40, 50]

def f(i):
    if i >= len(T):
        return
    ____
    f(2*i + 1)
    f(2*i + 2)]]></code>
    <input><![CDATA[f(0)]]></input>
    <output><![CDATA[10 20 40 50 30]]></output>
    <solution><![CDATA[T = [10, 20, 30, 40, 50]

def f(i):
    if i >= len(T):
        return
    print(T[i], end=' ')  # 정답: print(T[i], end=' ')
    f(2*i + 1)
    f(2*i + 2)

# 전위 순회: 부모를 먼저 방문 (재귀 호출 전에 print)
# 트리 구조:
#       10
#      /  \
#     20   30
#    / \
#   40 50
#
# 순회: 10 → 20 → 40 → 50 → 30]]></solution>
  </problem>

  <!-- 문제 6: 디버깅 (중위 순회 순서 오류) -->
  <problem>
    <description>다음 중위 순회 코드에 오류가 있습니다. 오류를 찾아 고치세요.</description>
    <code><![CDATA[T = [1, 2, 3, 4, 5, 6, 7]

def f(i):
    if i >= len(T):
        return
    print(T[i], end=' ')
    f(2*i + 1)
    f(2*i + 2)]]></code>
    <input><![CDATA[f(0)]]></input>
    <output><![CDATA[4 2 5 1 6 3 7]]></output>
    <solution><![CDATA[T = [1, 2, 3, 4, 5, 6, 7]

def f(i):
    if i >= len(T):
        return
    f(2*i + 1)  # 왼쪽 자식 먼저
    print(T[i], end=' ')  # 부모 방문
    f(2*i + 2)  # 오른쪽 자식

# 오류: print 위치가 잘못됨
# - 원래 코드는 전위 순회 (부모 → 왼쪽 → 오른쪽)
# - 중위 순회는 왼쪽 → 부모 → 오른쪽
#
# 순회 순서 비교:
# 전위: 1 2 4 5 3 6 7
# 중위: 4 2 5 1 6 3 7
#
# print 위치:
# - 전위: 재귀 호출 전
# - 중위: 왼쪽 재귀와 오른쪽 재귀 사이
# - 후위: 재귀 호출 후]]></solution>
  </problem>

  <!-- 문제 7: 순서 맞추기 (후위 순회 코드) -->
  <problem>
    <description>다음 코드 조각들을 올바른 순서로 배열하여 후위 순회를 구현하세요.
A: print(T[i], end=' ')
B: f(2*i + 1)
C: f(2*i + 2)
D: if i >= len(T): return</description>
    <code><![CDATA[T = [5, 3, 8, 1, 4]

def f(i):
    ____
    ____
    ____
    ____]]></code>
    <input><![CDATA[f(0)]]></input>
    <output><![CDATA[1 4 3 8 5]]></output>
    <solution><![CDATA[T = [5, 3, 8, 1, 4]

def f(i):
    if i >= len(T): return  # D
    f(2*i + 1)  # B
    f(2*i + 2)  # C
    print(T[i], end=' ')  # A

# 정답 순서: D → B → C → A
#
# 후위 순회: 왼쪽 → 오른쪽 → 부모
# 1. 기저 조건 확인 (D)
# 2. 왼쪽 자식 방문 (B)
# 3. 오른쪽 자식 방문 (C)
# 4. 부모 방문 (A)
#
# 트리:
#     5
#    / \
#   3   8
#  / \
# 1   4
#
# 순회: 1 → 4 → 3 → 8 → 5]]></solution>
  </problem>

  <!-- 문제 8: 전체 작성 (전위 순회) -->
  <problem>
    <description>배열로 표현된 이진 트리를 전위 순회하는 재귀함수를 작성하세요. 각 노드의 값을 공백으로 구분하여 출력하세요.</description>
    <code><![CDATA[T = [50, 30, 70, 20, 40, 60, 80]

def f(i):
    pass]]></code>
    <input><![CDATA[f(0)]]></input>
    <output><![CDATA[50 30 20 40 70 60 80]]></output>
    <solution><![CDATA[T = [50, 30, 70, 20, 40, 60, 80]

def f(i):
    if i >= len(T):
        return
    print(T[i], end=' ')
    f(2*i + 1)
    f(2*i + 2)

# 전위 순회 (Preorder Traversal)
# 방문 순서: 부모 → 왼쪽 자식 → 오른쪽 자식
#
# 트리 구조:
#        50
#       /  \
#      30   70
#     / \   / \
#    20 40 60 80
#
# 출력: 50 30 20 40 70 60 80]]></solution>
  </problem>

  <!-- 문제 9: 전체 작성 (중위 순회) -->
  <problem>
    <description>배열로 표현된 이진 트리를 중위 순회하는 재귀함수를 작성하세요. 각 노드의 값을 공백으로 구분하여 출력하세요.</description>
    <code><![CDATA[T = [50, 30, 70, 20, 40, 60, 80]

def f(i):
    pass]]></code>
    <input><![CDATA[f(0)]]></input>
    <output><![CDATA[20 30 40 50 60 70 80]]></output>
    <solution><![CDATA[T = [50, 30, 70, 20, 40, 60, 80]

def f(i):
    if i >= len(T):
        return
    f(2*i + 1)
    print(T[i], end=' ')
    f(2*i + 2)

# 중위 순회 (Inorder Traversal)
# 방문 순서: 왼쪽 자식 → 부모 → 오른쪽 자식
#
# 트리 구조:
#        50
#       /  \
#      30   70
#     / \   / \
#    20 40 60 80
#
# 출력: 20 30 40 50 60 70 80
#
# 특징: 이진 탐색 트리(BST)에서는 오름차순 정렬됨]]></solution>
  </problem>

  <!-- 문제 10: 트레이싱 (순회 함수 호출 순서) -->
  <problem>
    <description>다음 트리를 후위 순회할 때, 함수가 호출되는 인덱스 순서를 모두 나열하세요. (배열: [A, B, C, D])</description>
    <code><![CDATA[T = ['A', 'B', 'C', 'D']

def f(i):
    if i >= len(T):
        return
    f(2*i + 1)
    f(2*i + 2)
    print(T[i], end=' ')]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 트리 구조:
#     A(0)
#    /  \
#   B(1) C(2)
#   /
#  D(3)
#
# 후위 순회 호출 순서:
# 1. f(0) 호출
# 2. f(1) 호출 (0의 왼쪽)
# 3. f(3) 호출 (1의 왼쪽)
# 4. f(7) 호출 (3의 왼쪽) - 범위 초과, return
# 5. f(8) 호출 (3의 오른쪽) - 범위 초과, return
# 6. D 출력 (f(3) 완료)
# 7. f(4) 호출 (1의 오른쪽) - 범위 초과, return
# 8. B 출력 (f(1) 완료)
# 9. f(2) 호출 (0의 오른쪽)
# 10. f(5) 호출 (2의 왼쪽) - 범위 초과, return
# 11. f(6) 호출 (2의 오른쪽) - 범위 초과, return
# 12. C 출력 (f(2) 완료)
# 13. A 출력 (f(0) 완료)
#
# 호출된 인덱스 순서 (범위 내):
# 0 → 1 → 3 → 2
#
# 출력 순서: D B C A
#
# 정답: f(0) → f(1) → f(3) → f(2)]]></solution>
  </problem>

  <!-- 문제 11: 서술형 (BST에서 중위 순회 특징) -->
  <problem>
    <description>이진 탐색 트리(BST)를 중위 순회하면 어떤 특징이 있는지 설명하고, 그 이유를 서술하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# BST의 중위 순회 특징
#
# 특징: 오름차순으로 정렬된 결과를 얻음
#
# 이유:
# 1. BST의 정의:
#    - 왼쪽 서브트리의 모든 값 < 부모 노드의 값
#    - 오른쪽 서브트리의 모든 값 > 부모 노드의 값
#
# 2. 중위 순회 순서:
#    - 왼쪽 서브트리 → 부모 → 오른쪽 서브트리
#
# 3. 결합:
#    - 작은 값들(왼쪽) → 중간 값(부모) → 큰 값들(오른쪽)
#    - 이는 오름차순 정렬과 동일
#
# 예시:
#        50
#       /  \
#      30   70
#     / \   / \
#    20 40 60 80
#
# 중위 순회: 20, 30, 40, 50, 60, 70, 80
# → 완벽한 오름차순
#
# 활용:
# - BST에서 정렬된 데이터를 추출할 때 사용
# - 시간복잡도: O(n)
# - 공간복잡도: O(h), h는 트리 높이
#
# 참고:
# - 내림차순을 원하면 오른쪽 → 부모 → 왼쪽 순으로 순회]]></solution>
  </problem>

  <!-- 문제 12: 복잡도 분석 (순회 알고리즘) -->
  <problem>
    <description>이진 트리 순회 알고리즘(전위/중위/후위)의 시간복잡도와 공간복잡도를 분석하고, 노드 개수가 n=1000일 때와 n=1000000일 때의 차이를 설명하세요.</description>
    <code><![CDATA[def f(i):
    if i >= len(T):
        return
    f(2*i + 1)
    print(T[i], end=' ')
    f(2*i + 2)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 트리 순회 복잡도 분석
#
# 시간복잡도: O(n)
# - 각 노드를 정확히 1번씩 방문
# - n개 노드 → n번 방문
# - 순회 종류와 무관 (전위/중위/후위 모두 동일)
#
# 공간복잡도: O(h)
# - h = 트리 높이
# - 재귀 호출 스택의 최대 깊이
# - 최선: O(log n) (완전 이진 트리)
# - 최악: O(n) (편향 트리)
#
# 노드 개수별 비교:
#
# n = 1000 (완전 이진 트리):
# - 시간: 1000번 방문
# - 공간: 약 log₂(1000) ≈ 10 (스택 깊이)
# - 실행 시간: 즉시 완료
#
# n = 1000000 (완전 이진 트리):
# - 시간: 1000000번 방문
# - 공간: 약 log₂(1000000) ≈ 20 (스택 깊이)
# - 실행 시간: 약 0.1초
#
# n = 1000 (편향 트리):
# - 시간: 1000번 방문
# - 공간: 1000 (스택 깊이)
# - 위험: 스택 오버플로우 가능성
#
# 결론:
# - 시간: 선형 증가 (1000배 → 1000배)
# - 공간: 로그 증가 (완전 트리), 선형 증가 (편향 트리)
# - 완전 이진 트리가 효율적 (공간 O(log n))
#
# 참고:
# - Python 기본 재귀 한계: 약 1000
# - 깊은 트리는 반복문으로 구현 권장]]></solution>
  </problem>
</problems>
