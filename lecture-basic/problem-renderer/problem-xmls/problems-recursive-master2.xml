<?xml version="1.0" encoding="UTF-8"?>
<!--
  재귀함수 고급 연습 문제 - Master 레벨
  
  이 파일은 재귀함수를 완전히 마스터하고자 하는 고급 학습자를 위한 문제들입니다.
  복잡한 이중 재귀, 백트래킹, 분할정복 등 고급 재귀 기법을 다룹니다.
  
  학습 목표:
  - 복잡한 이중 재귀와 메모이제이션 이해
  - 백트래킹과 상태 공간 탐색 마스터
  - 분할정복 알고리즘의 재귀적 구현
  - 실무에서 사용되는 고전 알고리즘 구현
-->
<problems>
  <problem>
    <description><![CDATA[재귀함수와 백트래킹을 사용하여 2차원 미로에서 출발점에서 도착점까지의 경로를 찾는 함수를 작성하세요.
0은 갈 수 있는 길, 1은 벽을 나타냅니다. 상하좌우로만 이동 가능합니다.]]></description>
    <code><![CDATA[def solve_maze(maze, start, end):
    # 여기에 코드를 작성하세요
    pass
# 테스트
maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0], 
    [0, 0, 0, 1, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 0, 1, 0]
]
start = (0, 0)
end = (4, 4)
path = solve_maze(maze, start, end)
if path:
    print(f"경로를 찾았습니다: {path}")
else:
    print("경로가 없습니다.")]]></code>
    <input><![CDATA[maze with start=(0,0), end=(4,4)]]></input>
    <output><![CDATA[경로가 있다면 좌표 리스트 반환]]></output>
    <hint><![CDATA[백트래킹을 사용하세요. 현재 위치에서 상하좌우로 이동을 시도하고, 막다른 길이면 이전 위치로 돌아가세요. 방문한 곳은 표시하여 무한 루프를 방지하세요.]]></hint>
    <solution><![CDATA[def solve_maze(maze, start, end):
    def is_valid(x, y, visited):
        """현재 위치가 유효한지 확인"""
        rows, cols = len(maze), len(maze[0])
        return (0 <= x < rows and 0 <= y < cols and 
                maze[x][y] == 0 and not visited[x][y])
    
    def backtrack(x, y, visited, path):
        # 기저 조건: 목적지에 도달
        if (x, y) == end:
            return True
        
        # 상하좌우 이동 방향
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 상, 하, 좌, 우
        
        for dx, dy in directions:
            next_x, next_y = x + dx, y + dy
            
            if is_valid(next_x, next_y, visited):
                # 다음 위치를 방문 표시
                visited[next_x][next_y] = True
                path.append((next_x, next_y))
                
                # 재귀 호출
                if backtrack(next_x, next_y, visited, path):
                    return True
                
                # 백트래킹: 방문 표시 제거 및 경로에서 제거
                visited[next_x][next_y] = False
                path.pop()
        
        return False
    
    # 초기화
    rows, cols = len(maze), len(maze[0])
    visited = [[False] * cols for _ in range(rows)]
    path = [start]
    
    # 시작점을 방문 표시
    visited[start[0]][start[1]] = True
    
    # 백트래킹 시작
    if backtrack(start[0], start[1], visited, path):
        return path
    else:
        return None
# 모든 경로를 찾는 함수:
def find_all_paths(maze, start, end):
    """미로의 모든 경로를 찾는 함수"""
    def backtrack_all(x, y, visited, current_path, all_paths):
        # 기저 조건: 목적지에 도달
        if (x, y) == end:
            all_paths.append(current_path[:])  # 현재 경로의 복사본 저장
            return
        
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        for dx, dy in directions:
            next_x, next_y = x + dx, y + dy
            
            if is_valid_for_all(next_x, next_y, visited, maze):
                visited[next_x][next_y] = True
                current_path.append((next_x, next_y))
                
                backtrack_all(next_x, next_y, visited, current_path, all_paths)
                
                # 백트래킹
                visited[next_x][next_y] = False
                current_path.pop()
    
    def is_valid_for_all(x, y, visited, maze):
        rows, cols = len(maze), len(maze[0])
        return (0 <= x < rows and 0 <= y < cols and 
                maze[x][y] == 0 and not visited[x][y])
    
    rows, cols = len(maze), len(maze[0])
    visited = [[False] * cols for _ in range(rows)]
    all_paths = []
    
    visited[start[0]][start[1]] = True
    backtrack_all(start[0], start[1], visited, [start], all_paths)
    
    return all_paths
# 경로 시각화 함수:
def print_maze_with_path(maze, path):
    """미로와 경로를 함께 출력"""
    if not path:
        print("경로가 없습니다.")
        return
    
    # 경로를 집합으로 변환 (빠른 검색을 위해)
    path_set = set(path)
    
    rows, cols = len(maze), len(maze[0])
    for i in range(rows):
        for j in range(cols):
            if (i, j) in path_set:
                if (i, j) == path[0]:
                    print('S', end=' ')  # Start
                elif (i, j) == path[-1]:
                    print('E', end=' ')  # End
                else:
                    print('*', end=' ')  # Path
            elif maze[i][j] == 1:
                print('#', end=' ')  # Wall
            else:
                print('.', end=' ')  # Empty
        print()
# 최단 경로 찾기 (BFS 사용):
from collections import deque
def find_shortest_path(maze, start, end):
    """BFS를 사용한 최단 경로 찾기"""
    if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1:
        return None
    
    rows, cols = len(maze), len(maze[0])
    visited = [[False] * cols for _ in range(rows)]
    parent = {}  # 경로 추적을 위한 부모 정보
    
    queue = deque([start])
    visited[start[0]][start[1]] = True
    parent[start] = None
    
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while queue:
        x, y = queue.popleft()
        
        if (x, y) == end:
            # 경로 재구성
            path = []
            current = end
            while current is not None:
                path.append(current)
                current = parent[current]
            return path[::-1]  # 역순으로 반환
        
        for dx, dy in directions:
            next_x, next_y = x + dx, y + dy
            
            if (0 <= next_x < rows and 0 <= next_y < cols and
                maze[next_x][next_y] == 0 and not visited[next_x][next_y]):
                
                visited[next_x][next_y] = True
                parent[(next_x, next_y)] = (x, y)
                queue.append((next_x, next_y))
    
    return None
# 테스트 실행:
maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0], 
    [0, 0, 0, 1, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 0, 1, 0]
]
print("미로:")
for row in maze:
    for cell in row:
        print('#' if cell == 1 else '.', end=' ')
    print()
print("\n=== DFS 백트래킹 (첫 번째 경로) ===")
path = solve_maze(maze, (0, 0), (4, 4))
if path:
    print(f"경로: {path}")
    print("미로와 경로:")
    print_maze_with_path(maze, path)
else:
    print("경로를 찾을 수 없습니다.")
print("\n=== BFS (최단 경로) ===")
shortest = find_shortest_path(maze, (0, 0), (4, 4))
if shortest:
    print(f"최단 경로: {shortest}")
    print(f"최단 경로 길이: {len(shortest)}")]]></solution>
  </problem>
  
  <problem>
    <description><![CDATA[재귀함수와 백트래킹을 사용하여 n개 원소 중에서 r개를 선택하는 모든 조합을 생성하는 함수를 작성하세요.
예: [1,2,3,4]에서 2개 선택 → [[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]]]></description>
    <code><![CDATA[def generate_combinations(nums, r):
    # 여기에 코드를 작성하세요
    pass
# 테스트
result = generate_combinations([1, 2, 3, 4], 2)
print(f"[1,2,3,4]에서 2개 선택하는 조합:")
for combo in result:
    print(combo)
print(f"총 {len(result)}개")]]></code>
    <input><![CDATA[nums=[1,2,3,4], r=2]]></input>
    <output><![CDATA[[[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]]]></output>
    <hint><![CDATA[백트래킹을 사용하세요. 각 위치에서 현재 원소를 선택하거나 선택하지 않는 두 가지 경우를 모두 고려하세요. 조합의 크기가 r에 도달하면 결과에 추가하세요.]]></hint>
    <solution><![CDATA[def generate_combinations(nums, r):
    def backtrack(start_index, current_combination, all_combinations):
        # 기저 조건: 조합의 크기가 r에 도달
        if len(current_combination) == r:
            all_combinations.append(current_combination[:])  # 복사본 추가
            return
        
        # 남은 원소 개수가 필요한 개수보다 적으면 조기 종료
        remaining_needed = r - len(current_combination)
        remaining_available = len(nums) - start_index
        if remaining_available < remaining_needed:
            return
        
        # start_index부터 끝까지 각 원소에 대해 시도
        for i in range(start_index, len(nums)):
            # 현재 원소를 조합에 추가
            current_combination.append(nums[i])
            
            # 다음 원소부터 재귀 호출 (중복 방지를 위해 i+1부터 시작)
            backtrack(i + 1, current_combination, all_combinations)
            
            # 백트래킹: 현재 원소를 조합에서 제거
            current_combination.pop()
    
    result = []
    backtrack(0, [], result)
    return result
# 또 다른 구현 방식 (인덱스 기반):
def generate_combinations_v2(nums, r):
    def backtrack_v2(index, current_combination, all_combinations):
        # 기저 조건: 조합 완성
        if len(current_combination) == r:
            all_combinations.append(current_combination[:])
            return
        
        # 기저 조건: 더 이상 원소가 없음
        if index >= len(nums):
            return
        
        # 현재 원소를 포함하는 경우
        current_combination.append(nums[index])
        backtrack_v2(index + 1, current_combination, all_combinations)
        current_combination.pop()  # 백트래킹
        
        # 현재 원소를 포함하지 않는 경우
        backtrack_v2(index + 1, current_combination, all_combinations)
    
    result = []
    backtrack_v2(0, [], result)
    return result
# 비트 마스킹을 사용한 조합 생성:
def generate_combinations_bitmask(nums, r):
    """비트 마스킹을 사용한 조합 생성"""
    n = len(nums)
    result = []
    
    # 모든 가능한 비트 패턴을 확인
    for mask in range(1 << n):  # 2^n개의 패턴
        # 비트가 설정된 개수 확인
        if bin(mask).count('1') == r:
            combination = []
            for i in range(n):
                if mask & (1 << i):
                    combination.append(nums[i])
            result.append(combination)
    
    return result
# 동작 과정 예시 ([1,2,3,4]에서 2개 선택):
# backtrack(0, [], result):
#   i=0, nums[0]=1: current=[1]
#     backtrack(1, [1], result):
#       i=1, nums[1]=2: current=[1,2], len=2 → result에 [1,2] 추가
#       i=2, nums[2]=3: current=[1,3], len=2 → result에 [1,3] 추가  
#       i=3, nums[3]=4: current=[1,4], len=2 → result에 [1,4] 추가
#   i=1, nums[1]=2: current=[2]
#     backtrack(2, [2], result):
#       i=2, nums[2]=3: current=[2,3], len=2 → result에 [2,3] 추가
#       i=3, nums[3]=4: current=[2,4], len=2 → result에 [2,4] 추가
#   i=2, nums[2]=3: current=[3]
#     backtrack(3, [3], result):
#       i=3, nums[3]=4: current=[3,4], len=2 → result에 [3,4] 추가
# 조합의 개수 계산 (수학적 검증):
import math
def combination_count(n, r):
    """조합의 개수 계산: C(n,r) = n! / (r!(n-r)!)"""
    return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))
# 중복 조합 (원소를 중복해서 선택 가능):
def generate_combinations_with_repetition(nums, r):
    """중복 조합 생성 (같은 원소를 여러 번 선택 가능)"""
    def backtrack_rep(start_index, current_combination, all_combinations):
        if len(current_combination) == r:
            all_combinations.append(current_combination[:])
            return
        
        for i in range(start_index, len(nums)):
            current_combination.append(nums[i])
            # 중복 허용이므로 i부터 시작 (i+1이 아님)
            backtrack_rep(i, current_combination, all_combinations)
            current_combination.pop()
    
    result = []
    backtrack_rep(0, [], result)
    return result
# 성능 비교:
print(f"4개 중 2개 선택하는 조합의 개수: {combination_count(4, 2)}")
# 테스트 실행
test_nums = [1, 2, 3, 4]
test_r = 2
print(f"\n=== 일반 조합 ({test_nums}에서 {test_r}개 선택) ===")
combinations = generate_combinations(test_nums, test_r)
for combo in combinations:
    print(combo)
print(f"\n=== 중복 조합 ({test_nums}에서 {test_r}개 선택, 중복 허용) ===")
rep_combinations = generate_combinations_with_repetition(test_nums, test_r)
for combo in rep_combinations:
    print(combo)
# 시간 복잡도: O(C(n,r) * r) - 조합의 개수 × 각 조합 생성 시간
# 공간 복잡도: O(C(n,r) * r) - 모든 조합을 저장하는 공간]]></solution>
  </problem>
  
  
  <problem>
    <description><![CDATA[재귀함수를 사용하여 n번째 카탈란 수를 계산하는 함수를 작성하세요.
카탈란 수의 점화식: C(n) = Σ(i=0 to n-1) C(i) * C(n-1-i)
기저 조건: C(0) = 1
예: C(3) = C(0)*C(2) + C(1)*C(1) + C(2)*C(0) = 1*2 + 1*1 + 2*1 = 5]]></description>
    <code><![CDATA[def catalan_number(n):
    # 여기에 코드를 작성하세요
    pass
# 테스트
for i in range(6):
    print(f"C({i}) = {catalan_number(i)}")]]></code>
    <input><![CDATA[n=3]]></input>
    <output><![CDATA[5]]></output>
    <hint><![CDATA[기저 조건: n==0이면 1을 반환합니다. 재귀 호출: i=0부터 n-1까지 catalan_number(i) * catalan_number(n-1-i)를 모두 더합니다.]]></hint>
    <solution><![CDATA[def catalan_number(n):
    # 기저 조건: C(0) = 1
    if n <= 1:
        return 1
    
    # 점화식: C(n) = Σ(i=0 to n-1) C(i) * C(n-1-i)
    result = 0
    for i in range(n):
        result += catalan_number(i) * catalan_number(n - 1 - i)
    
    return result
# 동작 과정 예시 (catalan_number(3)):
# C(3) = C(0)*C(2) + C(1)*C(1) + C(2)*C(0)
#      = 1*2 + 1*1 + 2*1
#      = 2 + 1 + 2 = 5
#
# 여기서 C(2)를 계산하려면:
# C(2) = C(0)*C(1) + C(1)*C(0) = 1*1 + 1*1 = 2
# 메모이제이션을 사용한 효율적 구현:
def catalan_number_memo(n, memo={}):
    """메모이제이션을 사용한 카탈란 수 계산"""
    if n in memo:
        return memo[n]
    
    if n <= 1:
        return 1
    
    result = 0
    for i in range(n):
        result += catalan_number_memo(i, memo) * catalan_number_memo(n - 1 - i, memo)
    
    memo[n] = result
    return result
# 이항계수를 사용한 공식: C(n) = C(2n, n) / (n + 1)
def catalan_number_formula(n):
    """이항계수를 이용한 카탈란 수 계산"""
    if n <= 1:
        return 1
    
    # C(n) = C(2n, n) / (n + 1)
    # C(2n, n) = (2n)! / (n! * n!)
    from math import factorial
    return factorial(2 * n) // (factorial(n) * factorial(n) * (n + 1))
# 더 효율적인 공식 구현:
def catalan_number_efficient(n):
    """효율적인 카탈란 수 계산 (오버플로우 방지)"""
    if n <= 1:
        return 1
    
    # C(n) = (2n)! / ((n+1)! * n!) = (2n * (2n-1) * ... * (n+2)) / (n!)
    result = 1
    for i in range(n):
        result = result * (2 * n - i) // (i + 1)
    
    return result // (n + 1)
# 카탈란 수의 실제 응용:
# 1. 올바른 괄호 쌍의 개수
def count_valid_parentheses(n):
    """n개의 '('와 n개의 ')'로 만들 수 있는 올바른 괄호 쌍의 개수"""
    return catalan_number_memo(n)
# 2. 이진 트리의 개수  
def count_binary_trees(n):
    """n개 노드로 만들 수 있는 서로 다른 이진 탐색 트리의 개수"""
    return catalan_number_memo(n)
# 3. 다각형의 삼각분할
def count_triangulations(n):
    """n+2각형을 삼각형으로 분할하는 방법의 수"""
    return catalan_number_memo(n)
# 4. 산 경로 문제
def count_mountain_paths(n):
    """n×n 격자에서 대각선을 넘지 않고 (0,0)에서 (n,n)까지 가는 경로의 수"""
    return catalan_number_memo(n)
# 재귀적으로 올바른 괄호 문자열 생성:
def generate_parentheses(n):
    """n쌍의 올바른 괄호 문자열을 모두 생성"""
    def backtrack(current, open_count, close_count, max_n, result):
        # 기저 조건: n쌍 완성
        if len(current) == 2 * max_n:
            result.append(current)
            return
        
        # '(' 추가 (열린 괄호가 n개 미만일 때)
        if open_count < max_n:
            backtrack(current + '(', open_count + 1, close_count, max_n, result)
        
        # ')' 추가 (닫힌 괄호가 열린 괄호보다 적을 때)
        if close_count < open_count:
            backtrack(current + ')', open_count, close_count + 1, max_n, result)
    
    result = []
    backtrack('', 0, 0, n, result)
    return result
# 카탈란 수 수열: 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, ...
print("카탈란 수 수열:")
for i in range(10):
    print(f"C({i}) = {catalan_number_memo(i)}")
print(f"\n3쌍의 올바른 괄호 문자열 (총 {catalan_number_memo(3)}개):")
parentheses = generate_parentheses(3)
for p in parentheses:
    print(p)
# 성능 비교:
import time
def time_comparison(n):
    print(f"\nn={n}일 때 성능 비교:")
    
    # 순수 재귀 (작은 n에서만 테스트)
    if n <= 10:
        start = time.time()
        result1 = catalan_number(n)
        end = time.time()
        print(f"순수 재귀: {result1} (시간: {end-start:.6f}초)")
    
    # 메모이제이션
    start = time.time()
    result2 = catalan_number_memo(n)
    end = time.time()
    print(f"메모이제이션: {result2} (시간: {end-start:.6f}초)")
    
    # 공식 사용
    start = time.time()
    result3 = catalan_number_efficient(n)
    end = time.time()
    print(f"효율적 공식: {result3} (시간: {end-start:.6f}초)")
# 시간 복잡도:
# - 순수 재귀: O(4^n) - 매우 느림
# - 메모이제이션: O(n²) - 각 C(i)를 한 번씩만 계산
# - 공식 사용: O(n) - 가장 효율적
time_comparison(5)
time_comparison(15)]]></solution>
  </problem>
  
  <problem>
    <description><![CDATA[재귀함수를 사용하여 파스칼 삼각형의 n번째 행까지를 출력하는 함수를 작성하세요.
파스칼 삼각형: 각 원소는 위의 두 원소의 합으로 이루어짐
점화식: P(n,k) = P(n-1,k-1) + P(n-1,k)]]></description>
    <code><![CDATA[def pascal_triangle(n):
    # 여기에 코드를 작성하세요
    pass
def pascal_element(row, col):
    # 파스칼 삼각형의 특정 위치 값을 구하는 함수
    pass
# 테스트
print("파스칼 삼각형 (5행까지):")
pascal_triangle(5)]]></code>
    <input><![CDATA[5]]></input>
    <output><![CDATA[파스칼 삼각형이 출력됨]]></output>
    <hint><![CDATA[pascal_element(row, col) 함수를 먼저 구현하세요. 기저 조건: col==0 또는 col==row이면 1을 반환합니다. 재귀 호출: pascal_element(row-1, col-1) + pascal_element(row-1, col)을 반환합니다.]]></hint>
    <solution><![CDATA[def pascal_element(row, col):
    """파스칼 삼각형의 (row, col) 위치 원소 값 계산"""
    # 기저 조건: 양 끝은 항상 1
    if col == 0 or col == row:
        return 1
    
    # 재귀 호출: 파스칼 삼각형의 점화식
    return pascal_element(row - 1, col - 1) + pascal_element(row - 1, col)
def pascal_triangle(n):
    """파스칼 삼각형의 n번째 행까지 출력"""
    for row in range(n):
        # 각 행의 앞쪽 공백 (중앙 정렬을 위해)
        spaces = ' ' * (n - row - 1)
        print(spaces, end='')
        
        # 각 행의 원소들 출력
        for col in range(row + 1):
            value = pascal_element(row, col)
            print(f"{value:2}", end=' ')
        print()  # 줄바꿈
# 메모이제이션을 사용한 효율적 구현:
def pascal_element_memo(row, col, memo={}):
    """메모이제이션을 사용한 파스칼 삼각형 원소 계산"""
    if (row, col) in memo:
        return memo[(row, col)]
    
    if col == 0 or col == row:
        return 1
    
    result = pascal_element_memo(row - 1, col - 1, memo) + pascal_element_memo(row - 1, col, memo)
    memo[(row, col)] = result
    return result
def pascal_triangle_memo(n):
    """메모이제이션을 사용한 파스칼 삼각형"""
    memo = {}
    for row in range(n):
        spaces = ' ' * (n - row - 1)
        print(spaces, end='')
        
        for col in range(row + 1):
            value = pascal_element_memo(row, col, memo)
            print(f"{value:2}", end=' ')
        print()
# 동적 프로그래밍을 사용한 구현:
def pascal_triangle_dp(n):
    """동적 프로그래밍을 사용한 파스칼 삼각형"""
    # 2차원 배열로 삼각형 구성
    triangle = []
    
    for row in range(n):
        current_row = [1]  # 첫 번째 원소는 항상 1
        
        for col in range(1, row):
            # 위의 두 원소의 합
            value = triangle[row - 1][col - 1] + triangle[row - 1][col]
            current_row.append(value)
        
        if row > 0:
            current_row.append(1)  # 마지막 원소는 항상 1
        
        triangle.append(current_row)
    
    # 출력
    for row in range(n):
        spaces = ' ' * (n - row - 1)
        print(spaces, end='')
        
        for value in triangle[row]:
            print(f"{value:2}", end=' ')
        print()
    
    return triangle
# 각 행을 독립적으로 계산하는 방법:
def pascal_row(n):
    """파스칼 삼각형의 n번째 행만 계산"""
    if n == 0:
        return [1]
    
    prev_row = pascal_row(n - 1)
    current_row = [1]  # 첫 번째 원소
    
    # 중간 원소들 계산
    for i in range(len(prev_row) - 1):
        current_row.append(prev_row[i] + prev_row[i + 1])
    
    current_row.append(1)  # 마지막 원소
    return current_row
def pascal_triangle_by_rows(n):
    """각 행을 재귀적으로 계산하여 삼각형 구성"""
    for row in range(n):
        spaces = ' ' * (n - row - 1)
        print(spaces, end='')
        
        row_values = pascal_row(row)
        for value in row_values:
            print(f"{value:2}", end=' ')
        print()
# 이항계수와의 관계:
def pascal_as_binomial(row, col):
    """파스칼 삼각형의 원소를 이항계수로 계산"""
    from math import factorial
    return factorial(row) // (factorial(col) * factorial(row - col))
# 파스칼 삼각형의 흥미로운 성질들:
def pascal_properties():
    """파스칼 삼각형의 여러 성질들 확인"""
    print("=== 파스칼 삼각형의 성질들 ===\n")
    
    # 1. 각 행의 합은 2^n
    print("1. 각 행의 합:")
    for row in range(6):
        row_values = pascal_row(row)
        row_sum = sum(row_values)
        print(f"행 {row}: {row_values} → 합: {row_sum} = 2^{row}")
    
    # 2. 대각선의 합들
    print("\n2. 대각선별 원소들:")
    triangle = pascal_triangle_dp_return(6)
    
    # 왼쪽 대각선 (모두 1)
    print("왼쪽 대각선:", [triangle[i][0] for i in range(6)])
    
    # 두 번째 대각선 (자연수)
    print("두 번째 대각선:", [triangle[i][1] for i in range(1, 6)])
    
    # 세 번째 대각선 (삼각수)
    print("세 번째 대각선:", [triangle[i][2] for i in range(2, 6)])
    
    # 3. 피보나치 수와의 관계 (대각선의 합)
    print("\n3. 대각선 합과 피보나치 수:")
    for n in range(6):
        diagonal_sum = sum(triangle[i][n-i] for i in range(n+1) if n-i >= 0 and i < len(triangle))
        fib_n = fibonacci(n) if n >= 0 else 0
        print(f"n={n}: 대각선 합 = {diagonal_sum}")
def pascal_triangle_dp_return(n):
    """삼각형을 반환하는 DP 버전"""
    triangle = []
    for row in range(n):
        current_row = [1]
        for col in range(1, row):
            value = triangle[row - 1][col - 1] + triangle[row - 1][col]
            current_row.append(value)
        if row > 0:
            current_row.append(1)
        triangle.append(current_row)
    return triangle
def fibonacci(n):
    """피보나치 수 계산 (간단한 버전)"""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
# 성능 비교:
import time
def performance_comparison():
    n = 10
    print(f"\n=== {n}번째 행까지의 성능 비교 ===")
    
    # 순수 재귀
    start = time.time()
    print("순수 재귀 방식:")
    for row in range(min(n, 8)):  # 너무 느려서 8까지만
        row_values = [pascal_element(row, col) for col in range(row + 1)]
        print(f"행 {row}: {row_values}")
    end = time.time()
    print(f"시간: {end - start:.4f}초")
    
    # 메모이제이션
    start = time.time()
    memo = {}
    print("\n메모이제이션 방식:")
    for row in range(n):
        row_values = [pascal_element_memo(row, col, memo) for col in range(row + 1)]
        print(f"행 {row}: {row_values}")
    end = time.time()
    print(f"시간: {end - start:.4f}초")
    
    # 동적 프로그래밍
    start = time.time()
    print("\n동적 프로그래밍 방식:")
    triangle = pascal_triangle_dp_return(n)
    for i, row in enumerate(triangle):
        print(f"행 {i}: {row}")
    end = time.time()
    print(f"시간: {end - start:.4f}초")
# 실행 예시:
print("=== 기본 파스칼 삼각형 (재귀) ===")
pascal_triangle(6)
print("\n=== 파스칼 삼각형 (메모이제이션) ===")
pascal_triangle_memo(6)
print("\n=== 파스칼 삼각형 (동적 프로그래밍) ===")
pascal_triangle_dp(6)
# pascal_properties()
# performance_comparison()
# 시간 복잡도:
# - 순수 재귀: O(2^n) - 지수적으로 느림
# - 메모이제이션: O(n²) - 각 원소를 한 번씩만 계산
# - 동적 프로그래밍: O(n²) - 가장 효율적이고 직관적]]></solution>
  </problem>
</problems>