<?xml version="1.0" encoding="UTF-8"?>
<!--
  이 파일은 전역변수 사용 시 자주 발생하는 실수와 주의사항을 학습하기 위한
  문제들을 포함합니다. 각 문제는 전역변수 사용 시 흔히 겪는 오류 상황을 
  제시하고, 올바른 해결 방법을 익힐 수 있도록 구성되어 있습니다.
  
  학습 목표:
  - global 키워드 누락으로 인한 오류 이해
  - UnboundLocalError 발생 원인과 해결법 학습
  - 전역변수와 지역변수의 섀도잉(shadowing) 문제 인식
  - 전역변수 초기화 타이밍 이해
  - 전역변수 사용 시 발생할 수 있는 부작용 학습
-->
<problems>

  <!-- 1. global 선언 누락 오류 -->
  <problem>
    <description><![CDATA[다음 코드에서 발생하는 오류를 수정하세요.
전역변수를 수정하려면 global 키워드가 필요합니다.]]></description>
    <code><![CDATA[count = 0

def increment():
    count += 1
    return count

def fixed_increment():
    pass]]></code>
    <input><![CDATA[count = 0]]></input>
    <output><![CDATA[UnboundLocalError 발생!
수정 전 count: 0
수정 후 count: 1]]></output>
    <hint><![CDATA[함수 내에서 전역변수를 수정하려면 global 키워드를 사용해야 합니다.]]></hint>
    <solution><![CDATA[def fixed_increment():
    global count
    count += 1
    return count]]></solution>
  </problem>

  <!-- 2. 지역변수로 인한 섀도잉 -->
  <problem>
    <description><![CDATA[전역변수와 같은 이름의 지역변수로 인한 문제를 해결하세요.
의도한 대로 전역변수를 사용하도록 수정하세요.]]></description>
    <code><![CDATA[message = "전역 메시지"

def wrong_function():
    print(f"출력: {message}")
    message = "지역 메시지"
    print(f"변경 후: {message}")

def correct_function():
    pass]]></code>
    <input><![CDATA[message = "전역 메시지"]]></input>
    <output><![CDATA[잘못된 함수:
UnboundLocalError 발생!

올바른 함수:
출력: 전역 메시지
변경 후: 지역 메시지
전역 message: 지역 메시지]]></output>
    <hint><![CDATA[global 키워드를 함수 시작 부분에 선언하여 전역변수임을 명시하세요.]]></hint>
    <solution><![CDATA[def correct_function():
    global message
    print(f"출력: {message}")
    message = "지역 메시지"
    print(f"변경 후: {message}")]]></solution>
  </problem>

  <!-- 3. 초기화 순서 문제 -->
  <problem>
    <description><![CDATA[전역변수가 초기화되지 않은 상태에서 함수를 호출하는 문제를 해결하세요.
안전한 초기화 방법을 구현하세요.]]></description>
    <code><![CDATA[def unsafe_function():
    global data
    data += " 추가 데이터"
    return data

def safe_function():
    global data
    pass
    data += " 추가 데이터"
    return data]]></code>
    <input><![CDATA[data 변수 없음]]></input>
    <output><![CDATA[안전하지 않은 함수:
NameError 발생! 전역변수가 정의되지 않음

안전한 함수:
결과: 기본 데이터 추가 데이터]]></output>
    <hint><![CDATA[전역변수가 존재하지 않을 경우를 대비해 기본값으로 초기화하세요.]]></hint>
    <solution><![CDATA[def safe_function():
    global data
    if 'data' not in globals():
        data = "기본 데이터"
    data += " 추가 데이터"
    return data]]></solution>
  </problem>

  <!-- 4. 여러 함수의 전역변수 충돌 -->
  <problem>
    <description><![CDATA[여러 함수가 같은 전역변수를 동시에 수정할 때 발생할 수 있는 문제를 보여주고,
안전한 방법으로 수정하세요.]]></description>
    <code><![CDATA[shared_value = 10

def multiply_by_2():
    global shared_value
    shared_value *= 2

def add_5():
    global shared_value
    shared_value += 5

def safe_calculate():
    global shared_value
    pass]]></code>
    <input><![CDATA[shared_value = 10]]></input>
    <output><![CDATA[초기값: 10
2배 후: 20
5 추가 후: 25
안전한 계산 결과: 25
원본값 보존: 10]]></output>
    <hint><![CDATA[전역변수를 직접 수정하지 말고, 복사본을 만들어 계산하세요.]]></hint>
    <solution><![CDATA[def safe_calculate():
    global shared_value
    temp_value = shared_value
    temp_value *= 2
    temp_value += 5
    return temp_value]]></solution>
  </problem>

  <!-- 5. 리스트 참조 vs 재할당 문제 -->
  <problem>
    <description><![CDATA[리스트의 직접 수정과 재할당의 차이점을 이해하고,
각각 언제 global이 필요한지 보여주는 예제를 완성하세요.]]></description>
    <code><![CDATA[items = [1, 2, 3]

def modify_list():
    items.append(4)

def reassign_list():
    items = [5, 6, 7]

def correct_reassign():
    pass]]></code>
    <input><![CDATA[items = [1, 2, 3]]]></input>
    <output><![CDATA[초기 리스트: [1, 2, 3]
수정 후: [1, 2, 3, 4]
재할당 실패 - UnboundLocalError
재할당 전: [1, 2, 3, 4]
올바른 재할당 후: [5, 6, 7]]]></output>
    <hint><![CDATA[리스트를 재할당하려면 global 키워드가 필요합니다.]]></hint>
    <solution><![CDATA[def correct_reassign():
    global items
    items = [5, 6, 7]]]></solution>
  </problem>

  <!-- 6. 함수 정의 순서와 전역변수 -->
  <problem>
    <description><![CDATA[전역변수가 함수 정의 후에 선언될 때 발생하는 문제를 해결하세요.
안전한 접근 방법을 구현하세요.]]></description>
    <code><![CDATA[def use_config():
    return f"설정값: {config}"

def safe_use_config():
    pass

config = "중요한 설정"]]></code>
    <input><![CDATA[config = "중요한 설정"]]></input>
    <output><![CDATA[안전하지 않은 접근:
NameError 발생!

안전한 접근:
설정값: 중요한 설정]]></output>
    <hint><![CDATA[globals()를 사용하여 전역변수 존재 여부를 확인하거나 try-except를 사용하세요.]]></hint>
    <solution><![CDATA[def safe_use_config():
    try:
        return f"설정값: {config}"
    except NameError:
        return "설정값이 정의되지 않음"]]></solution>
  </problem>

  <!-- 7. 의도치 않은 부작용 -->
  <problem>
    <description><![CDATA[한 함수에서 전역변수를 변경했을 때 다른 함수에 미치는 영향을 보여주고,
부작용을 방지하는 방법을 구현하세요.]]></description>
    <code><![CDATA[user_score = 100

def dangerous_bonus():
    global user_score
    user_score *= 2

def get_score():
    return f"현재 점수: {user_score}"

def safe_bonus():
    pass]]></code>
    <input><![CDATA[user_score = 100]]></input>
    <output><![CDATA[현재 점수: 100
위험한 보너스 후: 현재 점수: 200
안전한 보너스: 200
원본 점수: 현재 점수: 100]]></output>
    <hint><![CDATA[전역변수를 직접 수정하지 말고, 계산 결과만 반환하세요.]]></hint>
    <solution><![CDATA[def safe_bonus():
    return user_score * 2]]></solution>
  </problem>

  <!-- 8. 전역변수 초기화 위치 문제 -->
  <problem>
    <description><![CDATA[전역변수 초기화를 함수 내부에서 하는 경우의 문제점을 보여주고,
올바른 초기화 방법을 구현하세요.]]></description>
    <code><![CDATA[def wrong_init():
    global database
    database = []
    database.append("첫 번째 데이터")

def add_data(data):
    database.append(data)

def correct_init():
    global database
    pass
    database.append("첫 번째 데이터")]]></code>
    <input><![CDATA[database 변수 없음]]></input>
    <output><![CDATA[잘못된 초기화:
데이터: ['첫 번째 데이터', '두 번째']
다시 호출 후: ['첫 번째 데이터']

올바른 초기화:
데이터: ['첫 번째 데이터', '두 번째']
다시 호출 후: ['첫 번째 데이터', '두 번째', '첫 번째 데이터']]]></output>
    <hint><![CDATA[전역변수가 이미 존재하는지 확인하고, 없을 때만 초기화하세요.]]></hint>
    <solution><![CDATA[def correct_init():
    global database
    if 'database' not in globals():
        database = []
    database.append("첫 번째 데이터")]]></solution>
  </problem>

  <!-- 9. 전역 상수와 변수의 혼동 -->
  <problem>
    <description><![CDATA[전역 상수(대문자)는 변경하면 안 되는데 실수로 변경하는 경우를 보여주고,
올바른 사용 방법을 구현하세요.]]></description>
    <code><![CDATA[MAX_ATTEMPTS = 3
attempts = 0

def wrong_usage():
    global MAX_ATTEMPTS, attempts
    attempts += 1
    if attempts > MAX_ATTEMPTS:
        MAX_ATTEMPTS = 5
        return "제한 완화됨"
    return f"시도 {attempts}/{MAX_ATTEMPTS}"

def correct_usage():
    global attempts
    pass]]></code>
    <input><![CDATA[MAX_ATTEMPTS = 3, attempts = 0]]></input>
    <output><![CDATA[초기 제한: 3
시도 1: 시도 1/3
시도 2: 시도 2/3
시도 3: 시도 3/3
시도 4: 제한 완화됨
시도 5: 제한 초과
시도 6: 제한 초과
최종 MAX_ATTEMPTS: 5]]></output>
    <hint><![CDATA[상수는 변경하지 말고, 제한 초과 시 적절한 메시지만 반환하세요.]]></hint>
    <solution><![CDATA[def correct_usage():
    global attempts
    attempts += 1
    if attempts > MAX_ATTEMPTS:
        return "제한 초과"
    return f"시도 {attempts}/{MAX_ATTEMPTS}"]]></solution>
  </problem>

  <!-- 10. 전역변수 vs 함수 매개변수 -->
  <problem>
    <description><![CDATA[전역변수에 의존하는 함수의 문제점을 보여주고,
매개변수를 사용하는 더 나은 방법을 구현하세요.]]></description>
    <code><![CDATA[current_user = "김철수"
user_level = 5

def bad_function():
    if user_level > 3:
        return f"{current_user}님은 고급 사용자입니다"
    return f"{current_user}님은 일반 사용자입니다"

def good_function(user_name, level):
    pass]]></code>
    <input><![CDATA[다양한 사용자와 레벨]]></input>
    <output><![CDATA[전역변수 의존 함수:
김철수님은 고급 사용자입니다
박영희님은 일반 사용자입니다

매개변수 사용 함수:
김철수님은 고급 사용자입니다
박영희님은 일반 사용자입니다]]></output>
    <hint><![CDATA[전역변수 대신 매개변수를 받아서 처리하면 더 예측 가능하고 테스트하기 쉬운 함수가 됩니다.]]></hint>
    <solution><![CDATA[def good_function(user_name, level):
    if level > 3:
        return f"{user_name}님은 고급 사용자입니다"
    return f"{user_name}님은 일반 사용자입니다"]]></solution>
  </problem>

</problems>