<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <problem>
    <description><![CDATA[while 조건문을 p <= ____ 로 할 때, 빈칸에 들어갈 가능한 최소값을 쓰고, 동작 과정을 포함하여 이유를 설명하시오.]]></description>
    <code><![CDATA[import queue

q0 = queue.Queue()
q1 = queue.Queue()
a = [36, 4, 77, 6, 128, 25, 9, 7, 1, 62, 99]
p = 1
while p <= ____:
    b = []
    for i in a:
        if (p&i)==0:
            q0.put(i)
        else:
            q1.put(i)
    while not q0.empty():
        b.append(q0.get())
    while not q1.empty():
        b.append(q1.get())

    a=b
    p<<=1

for i in a:
    print(i, end=' ')]]></code>
    <input><![CDATA[]]></input>
    <output><![CDATA[]]></output>
    <hint></hint>
    <solution><![CDATA[# 답: 64

# 이유: 배열의 최대값이 128이므로, 모든 비트 위치를 처리하려면
# 128의 가장 높은 비트까지 처리해야 합니다.
# 128 = 10000000(2진수)이므로 8번째 비트(2^7 = 128)까지 필요합니다.
# p는 1, 2, 4, 8, 16, 32, 64, 128 순으로 증가하므로
# p <= 64일 때까지 실행해야 마지막에 p가 128이 되어 최고 비트를 처리할 수 있습니다.

# 동작 과정:
# 1. p=1: 1번째 비트로 홀수/짝수 분리
# 2. p=2: 2번째 비트로 분리
# 3. p=4: 3번째 비트로 분리
# ...
# 7. p=64: 7번째 비트로 분리
# 8. p=128: 8번째 비트로 분리 (루프 종료)

# 이는 기수 정렬(Radix Sort) 알고리즘입니다.]]></solution>
  </problem>

  <problem>
    <description><![CDATA[p&i==0 일 때와 그렇지 않을 때, p와 i 사이 관계를 설명하시오.]]></description>
    <code><![CDATA[import queue

q0 = queue.Queue()
q1 = queue.Queue()
a = [36, 4, 77, 6, 128, 25, 9, 7, 1, 62, 99]
p = 1
while p < 256:
    b = []
    for i in a:
        if (p&i)==0:    # p&i==0 일 때와 그렇지 않을 때의 관계
            q0.put(i)
        else:
            q1.put(i)
    while not q0.empty():
        b.append(q0.get())
    while not q1.empty():
        b.append(q1.get())

    a=b
    p<<=1

for i in a:
    print(i, end=' ')]]></code>
    <input><![CDATA[]]></input>
    <output><![CDATA[]]></output>
    <hint></hint>
    <solution><![CDATA[# p&i는 p와 i의 비트 AND 연산입니다.

# p&i==0인 경우:
# - p의 해당 비트 위치에서 i의 비트가 0인 경우
# - 즉, i의 p번째 비트가 0인 숫자들

# p&i!=0인 경우:
# - p의 해당 비트 위치에서 i의 비트가 1인 경우
# - 즉, i의 p번째 비트가 1인 숫자들

# 예시: p=4 (100₂)일 때
# - 36 (100100₂): 4&36 = 4 ≠ 0 → q1으로
# - 25 (11001₂): 4&25 = 0 = 0 → q0으로

# 이를 통해 각 비트 위치별로 0과 1을 가진 숫자들을 분리하여 정렬합니다.]]></solution>
  </problem>

  <problem>
    <description><![CDATA[다음 코드에서 빈칸을 채워 올바르게 동작하도록 하시오.]]></description>
    <code><![CDATA[import queue

q0 = queue.Queue()
q1 = queue.Queue()
a = [36, 4, 77, 6, 128, 25, 9, 7, 1, 62, 99]
p = 1
while p < 256:
    b = []
    for i in a:
        if (p&i)==0:
            q0.put(i)
        else:
            q1.put(i)
    while not q0.empty():
        b.append(q0.get())
    while not q1.empty():
        b.append(q1.get())

    a=b
    ________    # 이 줄을 채우시오

for i in a:
    print(i, end=' ')]]></code>
    <input><![CDATA[]]></input>
    <output><![CDATA[]]></output>
    <hint></hint>
    <solution><![CDATA[# 답: p<<=1 또는 p = p * 2

# 설명:
# p<<=1은 p를 왼쪽으로 1비트 시프트하는 연산으로, p를 2배로 만듭니다.
# p = 1 → 2 → 4 → 8 → 16 → 32 → 64 → 128 → 256
# 각 반복에서 다음 비트 위치를 검사하기 위해 p값을 2배씩 증가시킵니다.

# 대안: p *= 2 또는 p = p << 1]]></solution>
  </problem>

  <problem>
    <description><![CDATA[주어진 코드의 출력 결과를 쓰시오.]]></description>
    <code><![CDATA[import queue

q0 = queue.Queue()
q1 = queue.Queue()
a = [36, 4, 77, 6, 128, 25, 9, 7, 1, 62, 99]
p = 1
while p < 256:
    b = []
    for i in a:
        if (p&i)==0:
            q0.put(i)
        else:
            q1.put(i)
    while not q0.empty():
        b.append(q0.get())
    while not q1.empty():
        b.append(q1.get())

    a=b
    p<<=1

for i in a:
    print(i, end=' ')]]></code>
    <input><![CDATA[]]></input>
    <output><![CDATA[1 4 6 7 9 25 36 62 77 99 128]]></output>
    <hint></hint>
    <solution><![CDATA[# 이 코드는 기수 정렬(Radix Sort) 알고리즘을 구현합니다.
# 각 비트 위치별로 0과 1을 가진 숫자들을 분리하여 정렬합니다.

# 최종 출력: 1 4 6 7 9 25 36 62 77 99 128
# 배열이 오름차순으로 정렬됩니다.]]></solution>
  </problem>
</problems>