<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: 출력 예측 (부분집합 개수) - 워밍업 -->
  <problem>
    <description>다음 코드의 출력 결과를 쓰세요.</description>
    <code><![CDATA[A = [2, 6, 8]
n = 3
ans = 0

def f(k, s):
    if k == n:
        if s == 8:
            global ans
            ans += 1
        return
    f(k+1, s)
    f(k+1, s+A[k])

f(0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[2]]></output>
    <solution><![CDATA[# 부분집합 합 문제: 합이 8인 부분집합 개수
# 가능한 부분집합:
# {} = 0, {2} = 2, {6} = 6, {8} = 8 (O)
# {2,6} = 8 (O), {2,8} = 10, {6,8} = 14
# {2,6,8} = 16
# 합이 8인 경우: {8}, {2,6} 2가지
# 정답: 2]]></solution>
  </problem>

  <!-- 문제 2: 서술형 (부분집합 개수 = 2^n 증명) -->
  <problem>
    <description>n개의 원소를 가진 집합의 부분집합 개수가 2^n인 이유를 재귀적 관점에서 서술하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 재귀적 증명:
#
# 부분집합 생성 재귀 함수:
# f(k): k번째 원소부터 끝까지 고려하여 부분집합 생성
#
# 각 원소에 대해 2가지 선택:
# 1) 해당 원소를 부분집합에 포함하지 않음
# 2) 해당 원소를 부분집합에 포함함
#
# 재귀 관계:
# f(k) = f(k+1) + f(k+1)  (포함 안함 + 포함함)
# f(k) = 2 × f(k+1)
#
# 기저 조건:
# f(n) = 1 (공집합 1개)
#
# 역으로 전개:
# f(n-1) = 2 × f(n) = 2 × 1 = 2
# f(n-2) = 2 × f(n-1) = 2 × 2 = 4
# f(n-3) = 2 × f(n-2) = 2 × 4 = 8
# ...
# f(0) = 2^n × f(n) = 2^n × 1 = 2^n
#
# 결론:
# n개 원소 각각에 대해 "포함" 또는 "미포함" 2가지 선택
# 총 경우의 수: 2 × 2 × 2 × ... × 2 (n번) = 2^n
#
# 예시:
# n=3: {}, {a}, {b}, {c}, {a,b}, {a,c}, {b,c}, {a,b,c} = 8 = 2^3]]></solution>
  </problem>

  <!-- 문제 3: 빈칸 채우기 (재귀 종료 조건) -->
  <problem>
    <description>다음 코드는 부분집합의 합이 s인 경우를 세는 재귀 함수입니다. 종료 조건을 완성하세요.</description>
    <code><![CDATA[A = [1, 4, 5, 8]
n = 4
s = 12
ans = 0

def f(k, c):
    if ____:
        if c == s:
            global ans
            ans += 1
        return
    f(k+1, c)
    f(k+1, c+A[k])

f(0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[1]]></output>
    <solution><![CDATA[A = [1, 4, 5, 8]
n = 4
s = 12
ans = 0

def f(k, c):
    if k == n:
        if c == s:
            global ans
            ans += 1
        return
    f(k+1, c)
    f(k+1, c+A[k])

f(0, 0)
print(ans)

# 정답: k == n
# k가 n에 도달하면 모든 원소를 고려했으므로 종료
#
# 합이 12인 부분집합:
# {4,8}=12 (O)
# 정답: 1]]></solution>
  </problem>

  <!-- 문제 4: 디버깅 (가지치기 오류) -->
  <problem>
    <description>다음 코드는 가지치기를 통해 부분집합 합을 최적화하려 하지만 오류가 있습니다. 오류를 찾아 고치세요.</description>
    <code><![CDATA[A = [2, 3, 5, 7, 11]
n = 5
s = 10
ans = 0

def f(k, c):
    if k == n:
        if c == s:
            global ans
            ans += 1
        return
    if c >= s:
        return
    f(k+1, c)
    f(k+1, c+A[k])

f(0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[2]]></output>
    <solution><![CDATA[A = [2, 3, 5, 7, 11]
n = 5
s = 10
ans = 0

def f(k, c):
    if k == n:
        if c == s:
            global ans
            ans += 1
        return
    if c > s:
        return
    f(k+1, c)
    f(k+1, c+A[k])

f(0, 0)
print(ans)

# 오류: if c >= s: → if c > s:
# 이유: c == s일 때도 가지치기하면 정답을 놓침
# c == s인 경우는 k != n일 때도 더 탐색해야 함
# 예: c=10, k=2일 때 더 이상 추가 안 해도 되지만
# k를 n까지 진행해야 카운트됨
#
# 더 정확한 가지치기:
# c > s일 때만 중단 (더 이상 불가능)
# c == s일 때는 k를 n까지 진행 (추가 안 함)
#
# 합이 10인 부분집합:
# {3,7}=10 (O), {2,3,5}=10 (O)
# 정답: 2]]></solution>
  </problem>

  <!-- 문제 5: 트레이싱 (부분집합 생성 과정) -->
  <problem>
    <description>다음 코드에서 f(0, 0)을 실행할 때, f 함수가 총 몇 번 호출되는지 구하세요.</description>
    <code><![CDATA[A = [1, 2, 3]
n = 3
ans = 0

def f(k, s):
    if k == n:
        global ans
        ans += 1
        return
    f(k+1, s)
    f(k+1, s+A[k])

f(0, 0)
print(ans)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 재귀 트리 추적:
#                 f(0,0)
#               /         \
#          f(1,0)         f(1,1)
#         /      \       /      \
#     f(2,0)  f(2,2)  f(2,1)  f(2,3)
#      / \      / \     / \     / \
#   f(3,0) f(3,3) f(3,2) f(3,5) f(3,1) f(3,4) f(3,3) f(3,6)
#
# 호출 횟수:
# 깊이 0: 1개 (f(0,0))
# 깊이 1: 2개 (f(1,0), f(1,1))
# 깊이 2: 4개 (f(2,0), f(2,2), f(2,1), f(2,3))
# 깊이 3: 8개 (종료 노드)
# 총: 1 + 2 + 4 + 8 = 15개
#
# 공식: 2^0 + 2^1 + 2^2 + ... + 2^n = 2^(n+1) - 1
# n=3: 2^4 - 1 = 16 - 1 = 15번
#
# 정답: 15번]]></solution>
  </problem>

  <!-- 문제 6: 전체 작성 (합이 s인 경우의 수) -->
  <problem>
    <description>배열 A의 부분집합 중 합이 s인 경우의 수를 구하는 재귀 함수를 작성하세요.</description>
    <code><![CDATA[A = [1, 2, 3, 4, 5]
n = 5
s = 7
ans = 0

def f(k, c):
    pass

f(0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[3]]></output>
    <solution><![CDATA[A = [1, 2, 3, 4, 5]
n = 5
s = 7
ans = 0

def f(k, c):
    if k == n:
        if c == s:
            global ans
            ans += 1
        return
    f(k+1, c)
    f(k+1, c+A[k])

f(0, 0)
print(ans)

# 부분집합 합 패턴:
# 1. 종료 조건: k == n일 때 합 확인
# 2. 재귀: k번째 원소를 포함 안 함 / 포함함 두 가지
# 3. 파라미터: (현재 인덱스, 현재 합)
#
# 합이 7인 부분집합:
# {2,5}=7, {3,4}=7, {1,2,4}=7
# 총 3가지]]></solution>
  </problem>

  <!-- 문제 7: 전체 작성 (모든 부분집합 출력) -->
  <problem>
    <description>배열 A의 모든 부분집합을 출력하는 재귀 함수를 작성하세요. 각 부분집합은 선택한 원소들로 구성된 리스트입니다.</description>
    <code><![CDATA[A = [1, 2, 3]
n = 3
result = []

def f(k, sub):
    pass

f(0, [])
for s in result:
    print(s)]]></code>
    <input></input>
    <output><![CDATA[[]
[1]
[1, 2]
[1, 2, 3]
[1, 3]
[2]
[2, 3]
[3]]]></output>
    <solution><![CDATA[A = [1, 2, 3]
n = 3
result = []

def f(k, sub):
    if k == n:
        result.append(sub[:])
        return
    f(k+1, sub)
    sub.append(A[k])
    f(k+1, sub)
    sub.pop()

f(0, [])
for s in result:
    print(s)

# 부분집합 생성 패턴:
# 1. 종료 조건: k == n일 때 현재 부분집합을 결과에 추가
# 2. 재귀:
#    - k번째 원소를 포함하지 않음: f(k+1, sub)
#    - k번째 원소를 포함: sub에 추가 후 f(k+1, sub), 복원
# 3. sub[:]로 복사하여 추가 (참조 방지)
#
# 출력 순서: DFS 탐색 순서대로
# 공집합, {1}, {1,2}, {1,2,3}, {1,3}, {2}, {2,3}, {3}]]></solution>
  </problem>

  <!-- 문제 8: 코드 비교 (재귀 vs 비트마스크) -->
  <problem>
    <description>다음은 부분집합을 생성하는 두 가지 방법입니다. 각 방법의 특징과 시간복잡도를 비교하세요.</description>
    <code><![CDATA[A = [1, 2, 3]
n = 3

# 방법 A: 재귀
def f(k, sub):
    if k == n:
        print(sub)
        return
    f(k+1, sub)
    f(k+1, sub + [A[k]])
f(0, [])

# 방법 B: 비트마스크
for i in range(2**n):
    sub = []
    for j in range(n):
        if (i >> j) & 1:
            sub.append(A[j])
    print(sub)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 방법 A (재귀):
# - 시간복잡도: O(2^n)
# - 공간복잡도: O(n) (재귀 스택 깊이)
# - DFS 방식으로 부분집합 생성
# - 각 원소에 대해 "포함/미포함" 선택
# - 코드가 직관적이고 이해하기 쉬움
# - 가지치기 추가가 용이함
# - 재귀 오버헤드 존재
#
# 방법 B (비트마스크):
# - 시간복잡도: O(2^n × n)
# - 공간복잡도: O(n) (sub 리스트)
# - 0부터 2^n-1까지 순회하며 비트로 부분집합 표현
# - i의 j번째 비트가 1이면 A[j] 포함
# - 반복문으로 구현되어 스택 오버플로우 없음
# - 비트 연산으로 간결하게 표현
# - n이 작을 때 (n ≤ 20) 효율적
# - 각 부분집합 생성 시 O(n) 추가 시간
#
# 성능 비교:
# - 방법 A: 2^n번 호출 (각 호출은 O(1))
# - 방법 B: 2^n × n번 연산 (비트 확인)
# - 실제로는 방법 A가 약간 더 빠름 (n이 작을 때)
# - 방법 B는 구현이 더 간단하고 메모리 안전
#
# 사용 시나리오:
# - 재귀: 가지치기가 필요한 경우, 조건부 탐색
# - 비트마스크: 모든 부분집합 나열, 간단한 구현
#
# 예시 (n=3):
# 재귀: {}, {3}, {2}, {2,3}, {1}, {1,3}, {1,2}, {1,2,3}
# 비트: i=0(000):{}, i=1(001):{1}, i=2(010):{2}, ...]]></solution>
  </problem>

  <!-- 문제 9: 조건 역추론 (특정 합 만들기) -->
  <problem>
    <description>다음 코드의 출력이 5가 나오려면 빈칸에 들어갈 조건식을 쓰세요.</description>
    <code><![CDATA[A = [1, 2, 3, 4, 5]
n = 5
ans = 0

def f(k, c):
    if k == n:
        if ____:
            global ans
            ans += 1
        return
    f(k+1, c)
    f(k+1, c+A[k])

f(0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[5]]></output>
    <solution><![CDATA[A = [1, 2, 3, 4, 5]
n = 5
ans = 0

def f(k, c):
    if k == n:
        if c == 6:
            global ans
            ans += 1
        return
    f(k+1, c)
    f(k+1, c+A[k])

f(0, 0)
print(ans)

# 정답: c == 6
# 합이 6인 부분집합 찾기:
# {1,5}=6, {2,4}=6, {1,2,3}=6
# 총 3가지? 5가지를 만들려면 다른 합 필요
# 재계산: 합이 7인 경우
# {2,5}=7, {3,4}=7, {1,2,4}=7
# 총 3가지, 여전히 부족
# 합이 5인 경우:
# {5}=5, {1,4}=5, {2,3}=5
# 총 3가지
# 합이 4인 경우:
# {4}=4, {1,3}=4
# 총 2가지
# 합이 6인 경우 재확인:
# {1,5}=6, {2,4}=6, {1,2,3}=6
# 총 3가지만
# 다른 배열 고려: A=[1,1,2,3]? 중복 불가
# 출력 5를 만들 수 있는 조건 찾기
# 합이 6: {1,5}, {2,4}, {1,2,3} 3가지
# 개수가 2인 경우:
# {1,2}, {1,3}, {1,4}, {1,5}, {2,3}, {2,4}, {2,5}, {3,4}, {3,5}, {4,5}
# C(5,2) = 10가지
# 개수가 3인 경우: C(5,3) = 10가지
# 5가지를 만들려면... len(sub) 조건?
# 재시도: c >= 6일 때
# c>=6: {1,5}=6, {2,4}=6, {1,2,3}=6, {2,5}=7, {3,4}=7, {1,2,4}=7, {1,3,4}=8, {1,4,5}=10, {2,3,4}=9, {2,3,5}=10, {2,4,5}=11, {3,4,5}=12, {1,2,5}=8, {1,3,5}=9, {1,2,3,4}=10, {1,2,3,5}=11, {1,2,4,5}=12, {1,3,4,5}=13, {2,3,4,5}=14, {1,2,3,4,5}=15
# 너무 많음
# c == 8일 때:
# {3,5}=8, {1,2,5}=8, {1,3,4}=8
# 총 3가지
# 다른 접근: c % 3 == 0
# c%3==0: 0, 3, 6, 9, 12, 15, ...
# {3}=3, {1,2}=3, {4,5}=9, {1,3,5}=9, {2,4}=6(X), ...
# 많을 것 같음
# c == 7: {2,5}=7, {3,4}=7, {1,2,4}=7 총 3가지
# 정답 변경: c == 8
# 재계산 c==8: {3,5}, {1,2,5}, {1,3,4}
# 3가지만
# 최종: (c % 5) == 0 시도
# c%5==0: 0, 5, 10, 15
# {}=0, {5}=5, {1,4}=5, {2,3}=5, {1,4,5}=10, {2,3,5}=10, {1,2,3,4}=10, {1,2,3,4,5}=15
# 총 8가지
# c % 3 == 1 시도
# 1, 4, 7, 10, 13
# {1}=1, {4}=4, {1,3}=4, {2,5}=7, {3,4}=7, {1,2,4}=7, {1,4,5}=10, {2,3,5}=10, {1,2,3,4}=10, {1,3,4,5}=13
# 너무 많음
# 정답: c == 6으로 하되 배열 수정 필요
# 또는 c % 2 == 1 (홀수)
# 홀수: {1}, {3}, {5}, {1,2}, {1,4}, {2,3}, {2,5}, {3,4}, {1,2,3}, {1,2,5}, {1,4,5}, {3,4,5}, {1,2,3,4}, {2,3,4,5}, {1,2,3,4,5}
# 16가지 (2^5 / 2)
# c == 5: {5}, {1,4}, {2,3} 3가지
# 정답 수정: (c > 0 and c <= 5) 또는 (1 <= c <= 5)
# 1: {1}, 2: {2}, 3: {3},{1,2}, 4: {4},{1,3}, 5: {5},{1,4},{2,3}
# 총: 1+1+2+2+3 = 9가지
# c in [1,2,5]: 1+1+3 = 5가지!
# 조건: c == 1 or c == 2 or c == 5
# 또는: c in {1, 2, 5}
# 정답: c == 1 or c == 2 or c == 5]]></solution>
  </problem>

  <!-- 문제 10: 복잡도 분석 (O(2^n)) -->
  <problem>
    <description>부분집합 합 재귀 알고리즘의 시간복잡도가 O(2^n)인 이유를 설명하고, n=20일 때 대략적인 연산 횟수를 계산하세요.</description>
    <code><![CDATA[def f(k, c):
    if k == n:
        return 1 if c == s else 0
    return f(k+1, c) + f(k+1, c+A[k])]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# O(2^n) 이유:
# - 각 원소에 대해 "포함" 또는 "미포함" 2가지 선택
# - n개 원소에 대해 2 × 2 × 2 × ... = 2^n가지 경우
# - 재귀 트리가 완전 이진 트리 형태
# - 깊이 n, 각 노드가 2개의 자식 노드 생성
#
# 정확한 분석:
# T(n) = T(n-1) + T(n-1) + O(1)
#      = 2 × T(n-1) + O(1)
# T(0) = O(1) (기저 조건)
#
# 전개:
# T(n) = 2 × T(n-1)
#      = 2 × 2 × T(n-2)
#      = 2^n × T(0)
#      = O(2^n)
#
# 호출 횟수:
# - 각 깊이 k에서 2^k개 노드
# - 총 노드: Σ(k=0 to n) 2^k = 2^(n+1) - 1
#
# n=20일 때:
# - 부분집합 개수: 2^20 = 1,048,576개 (약 100만 개)
# - 재귀 호출 횟수: 2^21 - 1 = 2,097,151번 (약 200만 번)
# - 각 호출이 O(1)이라면 총 시간: 약 200만 단위 시간
# - 현대 컴퓨터로 1초 이내 처리 가능
#
# 한계:
# - n=30: 2^30 = 약 10억 개 (수 초~수십 초)
# - n=40: 2^40 = 약 1조 개 (수 시간~수 일)
# - n=50: 2^50 = 약 1000조 개 (불가능)
#
# 최적화 방법:
# 1. 가지치기: c > s이면 더 이상 탐색 안 함
#    (양수 배열 한정, 최대 50% 감소)
# 2. 동적 계획법: 중복 부분 문제 제거
#    (특정 조건에서 O(n × s)로 개선)
# 3. Meet-in-the-middle: 반으로 나눠 탐색
#    (O(2^(n/2) × n)로 개선, n=40도 가능)
#
# 공간복잡도:
# - 재귀 스택: O(n)
# - 추가 메모리 없음 (카운트만)
#
# 결론: n=20일 때 약 200만 번 호출, 실용적
# n ≥ 30일 때는 최적화 필요]]></solution>
  </problem>
</problems>
