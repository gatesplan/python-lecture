<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: 출력 예측 (트리 높이) - 워밍업 -->
  <problem>
    <description>다음 코드의 출력 결과를 쓰세요.</description>
    <code><![CDATA[s = '-ABCDE'
T = {c: i for i, c in enumerate(s) if c != '-'}

def f(s, n):
    if n >= len(s) or s[n] == '-':
        return -1
    l = f(s, n*2)
    r = f(s, n*2+1)
    return max(l, r) + 1

print(f(s, 1))
print(f(s, 2))]]></code>
    <input></input>
    <output><![CDATA[2
1]]></output>
    <solution><![CDATA[# 트리 구조:
#      A(1)
#     /  \
#   B(2)  C(3)
#  / \
# D(4) E(5)
#
# f는 높이를 구하는 함수
# 높이 = 해당 노드에서 가장 먼 리프까지의 거리
#
# f(s, 1): 루트 A의 높이
# - f(2): B의 높이
#   - f(4): D의 높이 = 0 (리프)
#   - f(5): E의 높이 = 0 (리프)
#   - max(0, 0) + 1 = 1
# - f(3): C의 높이 = 0 (리프, 자식 없음)
# - max(1, 0) + 1 = 2
# 정답: 2
#
# f(s, 2): 노드 B의 높이
# - f(4): D의 높이 = 0 (리프)
# - f(5): E의 높이 = 0 (리프)
# - max(0, 0) + 1 = 1
# 정답: 1
#
# 최종 답: 2, 1]]></solution>
  </problem>

  <!-- 문제 2: 서술형 (높이 vs 깊이 차이) -->
  <problem>
    <description>트리에서 '높이(height)'와 '깊이(depth)'의 차이를 설명하고, 각각을 언제 사용하는지 서술하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 높이(Height) vs 깊이(Depth)
#
# 1. 깊이(Depth) - 위에서 아래로
#
# 정의:
# - 루트로부터 해당 노드까지의 거리
# - 루트에서 출발하여 몇 단계 내려왔는가
# - 레벨(Level)과 같은 의미
#
# 예시:
#        A (깊이 0)
#       / \
#      B   C (깊이 1)
#     / \
#    D   E (깊이 2)
#
# - 루트 A: 깊이 0
# - 노드 B, C: 깊이 1
# - 노드 D, E: 깊이 2
#
# 특징:
# - 각 노드마다 하나의 깊이 값
# - 루트의 깊이는 항상 0
# - 깊이가 같은 노드들 = 같은 레벨
#
# 2. 높이(Height) - 아래에서 위로
#
# 정의:
# - 해당 노드에서 가장 먼 리프까지의 거리
# - 서브트리에서 가장 깊은 경로의 길이
#
# 예시:
#        A (높이 2)
#       / \
#      B   C (높이 0)
#  (높이 1)
#     / \
#    D   E (높이 0)
# (높이 0)
#
# - 리프 D, E, C: 높이 0 (자식 없음)
# - 노드 B: 높이 1 (자식 D, E로부터 1칸)
# - 루트 A: 높이 2 (가장 먼 리프 D, E로부터 2칸)
#
# 특징:
# - 각 노드마다 하나의 높이 값
# - 리프의 높이는 항상 0
# - 트리의 높이 = 루트의 높이
#
# 3. 핵심 차이점
#
# | 특성 | 깊이(Depth) | 높이(Height) |
# |------|-------------|-------------|
# | 기준점 | 루트 | 리프 |
# | 방향 | 위→아래 | 아래→위 |
# | 루트 | 0 | 최대값 |
# | 리프 | 최대값 | 0 |
# | 트리 전체 | - | 루트의 높이 |
#
# 4. 언제 사용하는가?
#
# 깊이(Depth) 사용:
# - 레벨별 처리: BFS, 레벨 순서 순회
# - 노드의 위치 파악: 몇 번째 층인가?
# - 트리 시각화: 같은 깊이 = 같은 줄
# - 경로 추적: 루트부터 현재까지 거리
#
# 높이(Height) 사용:
# - 트리 균형 판단: AVL 트리, Red-Black 트리
# - 서브트리 크기 비교
# - 재귀 알고리즘: 후위 순회 방식
# - 트리 복잡도 분석: 시간복잡도 O(h)
#
# 5. 관계식
#
# 특정 노드 x에 대해:
# - depth(x) + height(x) ≤ height(tree)
# - 등호 성립: x가 가장 긴 경로 위에 있을 때
#
# 완전 이진 트리에서:
# - 노드 개수 n, 높이 h
# - h = floor(log₂(n))
# - 깊이 d인 레벨의 노드 수 ≤ 2^d
#
# 6. 계산 방법
#
# 깊이 계산 (반복):
# def depth(node):
#     d = 0
#     while node != root:
#         node = parent(node)
#         d += 1
#     return d
#
# 높이 계산 (재귀):
# def height(node):
#     if node is None:
#         return -1  # 또는 0 (정의에 따라)
#     return 1 + max(height(left), height(right))]]></solution>
  </problem>

  <!-- 문제 3: 빈칸 채우기 (노드 개수) -->
  <problem>
    <description>트리의 전체 노드 개수를 구하는 재귀 함수입니다. 빈칸을 채우세요.</description>
    <code><![CDATA[s = '-ABCDE'

def f(s, n):
    if n >= len(s) or s[n] == '-':
        return ____
    l = f(s, n*2)
    r = f(s, n*2+1)
    return ____ + ____ + ____]]></code>
    <input><![CDATA[print(f(s, 1))
print(f(s, 2))]]></input>
    <output><![CDATA[5
3]]></output>
    <solution><![CDATA[s = '-ABCDE'

def f(s, n):
    if n >= len(s) or s[n] == '-':
        return 0  # 정답 1: 0
    l = f(s, n*2)
    r = f(s, n*2+1)
    return 1 + l + r  # 정답 2, 3, 4: 1, l, r (순서 무관)

# 트리 구조:
#      A(1)
#     /  \
#   B(2)  C(3)
#  / \
# D(4) E(5)
#
# 노드 개수 = 1(현재) + 왼쪽 서브트리 + 오른쪽 서브트리
#
# f(s, 1): A 서브트리 노드 개수
# - l = f(2) = B 서브트리 = 3개 (B, D, E)
# - r = f(3) = C 서브트리 = 1개 (C)
# - 1 + 3 + 1 = 5개
#
# f(s, 2): B 서브트리 노드 개수
# - l = f(4) = D 서브트리 = 1개 (D)
# - r = f(5) = E 서브트리 = 1개 (E)
# - 1 + 1 + 1 = 3개
#
# 기저 조건:
# - 빈 노드(-)이거나 범위 밖: 0개 반환
#
# 재귀 관계:
# - count(node) = 1 + count(left) + count(right)]]></solution>
  </problem>

  <!-- 문제 4: 전체 작성 (리프 개수) -->
  <problem>
    <description>트리의 리프 노드 개수를 구하는 재귀 함수를 작성하세요. 리프는 자식이 없는 노드입니다.</description>
    <code><![CDATA[s = '-ABCDE'

def f(s, n):
    pass]]></code>
    <input><![CDATA[print(f(s, 1))
print(f(s, 2))]]></input>
    <output><![CDATA[3
2]]></output>
    <solution><![CDATA[s = '-ABCDE'

def f(s, n):
    if n >= len(s) or s[n] == '-':
        return 0
    l = n * 2
    r = n * 2 + 1
    if (l >= len(s) or s[l] == '-') and (r >= len(s) or s[r] == '-'):
        return 1
    return f(s, l) + f(s, r)

# 트리 구조:
#      A(1)
#     /  \
#   B(2)  C(3)  ← 리프
#  / \
# D(4) E(5)  ← 리프
#
# 리프 조건:
# - 왼쪽 자식도 없고 오른쪽 자식도 없음
#
# f(s, 1): 전체 트리의 리프 개수
# - A는 리프 아님 (자식 B, C 있음)
# - f(2): B 서브트리의 리프
#   - B는 리프 아님 (자식 D, E 있음)
#   - f(4): D는 리프 → 1
#   - f(5): E는 리프 → 1
#   - 합계: 2
# - f(3): C 서브트리의 리프
#   - C는 리프 → 1
# - 합계: 2 + 1 = 3
#
# f(s, 2): B 서브트리의 리프 개수
# - D는 리프 → 1
# - E는 리프 → 1
# - 합계: 2
#
# 다른 구현 방법:
def f2(s, n):
    if n >= len(s) or s[n] == '-':
        return 0
    l = f2(s, n*2)
    r = f2(s, n*2+1)
    if l == 0 and r == 0:
        return 1
    return l + r]]></solution>
  </problem>

  <!-- 문제 5: 디버깅 (높이 계산 오류) -->
  <problem>
    <description>다음 트리 높이 계산 함수에 오류가 있습니다. 오류를 찾아 고치세요.</description>
    <code><![CDATA[s = '-ABCDE'

def f(s, n):
    if n >= len(s) or s[n] == '-':
        return 0
    l = f(s, n*2)
    r = f(s, n*2+1)
    return max(l, r) + 1]]></code>
    <input><![CDATA[print(f(s, 1))]]></input>
    <output><![CDATA[2]]></output>
    <solution><![CDATA[s = '-ABCDE'

def f(s, n):
    if n >= len(s) or s[n] == '-':
        return -1  # 오류: 0이 아니라 -1
    l = f(s, n*2)
    r = f(s, n*2+1)
    return max(l, r) + 1

# 잘못된 부분: return 0
#
# 이유:
# - 빈 노드의 높이를 0으로 반환하면 계산이 잘못됨
# - 리프 노드의 높이가 1이 되어버림
#
# 예시:
#      A
#     /  \
#   B     C
#  / \
# D   E
#
# 잘못된 계산 (return 0):
# f(D): D의 자식들 = 빈 노드
# - l = 0, r = 0
# - max(0, 0) + 1 = 1  ← 리프인데 높이가 1?
#
# f(B):
# - l = f(D) = 1
# - r = f(E) = 1
# - max(1, 1) + 1 = 2
#
# f(A):
# - l = f(B) = 2
# - r = f(C) = 1
# - max(2, 1) + 1 = 3  ← 실제로는 2여야 함!
#
# 올바른 계산 (return -1):
# f(D): D의 자식들 = 빈 노드
# - l = -1, r = -1
# - max(-1, -1) + 1 = 0  ← 리프의 높이 = 0 ✅
#
# f(B):
# - l = f(D) = 0
# - r = f(E) = 0
# - max(0, 0) + 1 = 1
#
# f(A):
# - l = f(B) = 1
# - r = f(C) = 0
# - max(1, 0) + 1 = 2  ← 올바름 ✅
#
# 높이 정의에 따른 두 가지 방식:
#
# 방식 1: 빈 노드 = -1, 리프 = 0
# - 높이 = 노드에서 리프까지 간선 개수
# - 가장 일반적인 정의
#
# 방식 2: 빈 노드 = 0, 리프 = 1
# - 높이 = 노드에서 리프까지 노드 개수
# - 덜 일반적
#
# 문제에서는 방식 1 사용 (간선 개수)
# 따라서 빈 노드는 -1 반환해야 함]]></solution>
  </problem>

  <!-- 문제 6: 서술형 (완전 vs 포화 차이) -->
  <problem>
    <description>완전 이진 트리(Complete Binary Tree)와 포화 이진 트리(Perfect Binary Tree)의 차이를 설명하고, 각각의 예시를 들어 비교하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 완전 이진 트리 vs 포화 이진 트리
#
# 1. 포화 이진 트리 (Perfect Binary Tree)
#
# 정의:
# - 모든 레벨이 완전히 채워진 트리
# - 모든 리프가 같은 레벨
# - 모든 내부 노드가 정확히 2개의 자식
#
# 예시:
#        A
#       / \
#      B   C
#     / \ / \
#    D  E F  G
#
# 특징:
# - 높이 h일 때 노드 개수 = 2^(h+1) - 1
#   - h=0: 1개 (2^1 - 1)
#   - h=1: 3개 (2^2 - 1)
#   - h=2: 7개 (2^3 - 1)
#   - h=3: 15개 (2^4 - 1)
# - 가장 균형잡힌 형태
# - 배열 표현 시 빈 공간 없음
# - 레벨 k의 노드 개수 = 2^k
#
# 2. 완전 이진 트리 (Complete Binary Tree)
#
# 정의:
# - 마지막 레벨을 제외한 모든 레벨이 완전히 채워짐
# - 마지막 레벨은 왼쪽부터 순서대로 채워짐
# - 중간에 빈 공간 없이 왼쪽부터 연속
#
# 예시 1 (완전 O):
#        A
#       / \
#      B   C
#     / \ /
#    D  E F
#
# 예시 2 (완전 O):
#        A
#       / \
#      B   C
#     /
#    D
#
# 예시 3 (완전 X):
#        A
#       / \
#      B   C
#       \   \
#        E   F
# (D 위치가 비었는데 E가 있음 - 왼쪽부터가 아님)
#
# 특징:
# - 배열 표현 효율적 (빈 공간 최소)
# - 힙(Heap)이 완전 이진 트리
# - 부모-자식 인덱스 관계 명확:
#   - 부모: i // 2
#   - 왼쪽 자식: 2 * i
#   - 오른쪽 자식: 2 * i + 1
# - 높이 h일 때 노드 개수: 2^h ≤ n ≤ 2^(h+1) - 1
#
# 3. 비교표
#
# | 특성 | 완전 이진 트리 | 포화 이진 트리 |
# |------|---------------|---------------|
# | 마지막 레벨 | 왼쪽부터 채워짐 | 완전히 채워짐 |
# | 모든 리프 깊이 | 같거나 1 차이 | 모두 같음 |
# | 노드 개수 | 2^h ~ 2^(h+1)-1 | 정확히 2^(h+1)-1 |
# | 유연성 | 높음 | 낮음 (엄격) |
# | 포함 관계 | 포화 ⊂ 완전 | - |
#
# 4. 관계
#
# - 모든 포화 이진 트리는 완전 이진 트리다 ✅
# - 모든 완전 이진 트리가 포화 이진 트리는 아니다 ❌
#
# 예시:
#     A
#    / \
#   B   C
#  /
# D
# → 완전 O, 포화 X
#
#      A
#     / \
#    B   C
#   / \ / \
#  D  E F  G
# → 완전 O, 포화 O
#
# 5. 판별 방법
#
# 완전 이진 트리 판별:
# - BFS로 순회
# - 빈 노드를 만난 후 더 이상 노드가 없어야 함
#
# def is_complete(s):
#     found_empty = False
#     for i in range(1, len(s)):
#         if s[i] == '-':
#             found_empty = True
#         elif found_empty:
#             return False  # 빈 노드 후에 노드 발견
#     return True
#
# 포화 이진 트리 판별:
# - 모든 레벨이 가득 참
# - 노드 개수 = 2^(h+1) - 1
#
# def is_perfect(s, h):
#     count = sum(1 for c in s if c != '-')
#     return count == 2**(h+1) - 1
#
# 6. 실제 활용
#
# 완전 이진 트리:
# - 힙(Heap): 우선순위 큐 구현
# - 힙 정렬(Heap Sort)
# - 배열 기반 트리 표현
#
# 포화 이진 트리:
# - 세그먼트 트리(Segment Tree)
# - 이론적 분석 (최적의 경우)
# - 완벽한 균형 예시]]></solution>
  </problem>

  <!-- 문제 7: 전체 작성 (완전 트리 판별) -->
  <problem>
    <description>배열 표현된 트리가 완전 이진 트리인지 판별하는 함수를 작성하세요. 완전 이진 트리는 빈 노드('-') 이후에 더 이상 노드가 없어야 합니다.</description>
    <code><![CDATA[def f(s):
    pass]]></code>
    <input><![CDATA[print(f('-ABCDE'))
print(f('-ABC-E'))
print(f('-ABCDEFG'))]]></input>
    <output><![CDATA[True
False
True]]></output>
    <solution><![CDATA[def f(s):
    e = False
    for i in range(1, len(s)):
        if s[i] == '-':
            e = True
        elif e:
            return False
    return True

# 완전 이진 트리 판별 알고리즘:
# - 왼쪽부터 순서대로 채워져야 함
# - 배열 표현에서: 빈 노드 이후 노드가 없어야 함
#
# f('-ABCDE'):
# 트리:      A(1)
#           /  \
#         B(2)  C(3)
#        / \
#      D(4) E(5)
# 인덱스 순서: A B C D E
# 빈 노드 없음 → True
#
# f('-ABC-E'):
# 트리:      A(1)
#           /  \
#         B(2)  C(3)
#               \
#                E(5)
# 인덱스 순서: A B C - E
# 4번이 비었는데 5번에 노드 있음 → False
#
# f('-ABCDEFG'):
# 트리:        A(1)
#           /      \
#         B(2)      C(3)
#        /  \      /  \
#      D(4) E(5) F(6) G(7)
# 인덱스 순서: A B C D E F G
# 빈 노드 없음, 포화 이진 트리 → True
#
# 알고리즘 설명:
# 1. e = False로 초기화 (빈 노드를 아직 못 봄)
# 2. 인덱스 1부터 순회 (0은 더미)
# 3. 빈 노드('-')를 만나면 e = True
# 4. 빈 노드 이후(e == True)에 노드를 만나면 False
# 5. 끝까지 문제없으면 True
#
# 시간복잡도: O(n)
# 공간복잡도: O(1)
#
# 다른 구현 (더 간결):
def f2(s):
    return '-' not in s[1:] or s[s.rindex('-')+1:].count('-') == len(s) - s.rindex('-') - 1

# 또 다른 구현 (BFS 방식):
def f3(s):
    last_idx = 0
    for i in range(1, len(s)):
        if s[i] != '-':
            last_idx = i
    for i in range(1, last_idx+1):
        if s[i] == '-':
            return False
    return True]]></solution>
  </problem>

  <!-- 문제 8: 조건 역추론 (높이 h일 때 최대 노드) -->
  <problem>
    <description>높이가 h인 이진 트리가 가질 수 있는 최소 노드 개수와 최대 노드 개수를 구하는 공식을 작성하고, 그 이유를 설명하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 높이 h인 이진 트리의 노드 개수
#
# 1. 최대 노드 개수: 2^(h+1) - 1
#
# 이유:
# - 모든 레벨이 가득 찬 경우 (포화 이진 트리)
# - 레벨 0: 2^0 = 1개
# - 레벨 1: 2^1 = 2개
# - 레벨 2: 2^2 = 4개
# - ...
# - 레벨 h: 2^h 개
#
# 총 노드 개수:
# = 2^0 + 2^1 + 2^2 + ... + 2^h
# = 2^(h+1) - 1  (등비수열의 합)
#
# 예시:
# h=0:       A         → 1개 = 2^1 - 1
#
# h=1:       A         → 3개 = 2^2 - 1
#           / \
#          B   C
#
# h=2:       A         → 7개 = 2^3 - 1
#           / \
#          B   C
#         / \ / \
#        D  E F  G
#
# h=3:                 → 15개 = 2^4 - 1
# (포화 이진 트리)
#
# 2. 최소 노드 개수: h + 1
#
# 이유:
# - 한쪽으로만 뻗은 경우 (편향 트리)
# - 각 레벨에 1개씩만 있음
# - 높이 h까지 가려면 최소 h+1개 노드 필요
#
# 예시:
# h=0:    A            → 1개 = 0 + 1
#
# h=1:    A            → 2개 = 1 + 1
#        /
#       B
#
# h=2:    A            → 3개 = 2 + 1
#        /
#       B
#      /
#     C
#
# h=3:    A            → 4개 = 3 + 1
#        /
#       B
#      /
#     C
#    /
#   D
#
# 3. 공식 정리
#
# 높이 h인 이진 트리의 노드 개수 n:
#
# h + 1 ≤ n ≤ 2^(h+1) - 1
#
# 역으로, 노드 개수 n일 때 높이 h:
#
# log₂(n+1) - 1 ≤ h ≤ n - 1
#
# 4. 예시로 검증
#
# h=2인 트리:
# - 최소: 3개 = 2 + 1 ✅
# - 최대: 7개 = 2^3 - 1 ✅
#
#    A          A           A
#   /          / \         / \
#  B          B   C       B   C
# /          /           / \ / \
#C          D           D  E F  G
#(3개)      (4개)       (7개)
#
# 5. 완전 이진 트리의 경우
#
# 높이 h인 완전 이진 트리:
#
# 2^h ≤ n ≤ 2^(h+1) - 1
#
# - 최소: 마지막 레벨에 노드 1개
# - 최대: 포화 이진 트리
#
# 예: h=2
# - 최소: 4개 = 2^2
# - 최대: 7개 = 2^3 - 1
#
#      A              A
#     / \            / \
#    B   C          B   C
#   /              / \ / \
#  D              D  E F  G
# (4개)          (7개)
#
# 6. 높이와 노드 개수의 관계
#
# 주어진 n개 노드로 만들 수 있는:
#
# 최소 높이 (가장 균형잡힌 경우):
# h_min = ceil(log₂(n+1)) - 1
# ≈ log₂(n)
#
# 최대 높이 (가장 편향된 경우):
# h_max = n - 1
#
# 예: n=7
# - 최소 높이: ceil(log₂(8)) - 1 = 3 - 1 = 2
# - 최대 높이: 7 - 1 = 6
#
# 7. 시간복잡도와의 관계
#
# 트리 연산의 시간복잡도는 보통 O(h)
#
# - 최선 (균형): O(log n)
# - 최악 (편향): O(n)
#
# 따라서 균형 유지가 중요!
# → AVL 트리, Red-Black 트리 등]]></solution>
  </problem>

  <!-- 문제 9: 복잡도 분석 -->
  <problem>
    <description>트리의 높이를 구하는 재귀 함수의 시간복잡도와 공간복잡도를 분석하세요.</description>
    <code><![CDATA[def f(s, n):
    if n >= len(s) or s[n] == '-':
        return -1
    l = f(s, n*2)
    r = f(s, n*2+1)
    return max(l, r) + 1]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 트리 높이 계산의 복잡도 분석
#
# 함수 동작:
# - 후위 순회 방식
# - 모든 노드를 한 번씩 방문
# - 각 노드에서 왼쪽/오른쪽 재귀 호출
#
# 1. 시간복잡도: O(n)
#
# 분석:
# - n = 트리의 노드 개수
# - 각 노드에서 수행하는 작업:
#   1. 기저 조건 확인: O(1)
#   2. 왼쪽 재귀 호출: T(left)
#   3. 오른쪽 재귀 호출: T(right)
#   4. max와 +1 연산: O(1)
#
# 점화식:
# T(n) = T(left) + T(right) + O(1)
#
# 전개:
# - 왼쪽 서브트리의 모든 노드: O(left)
# - 오른쪽 서브트리의 모든 노드: O(right)
# - 현재 노드: O(1)
# - 합계: O(left + right + 1) = O(n)
#
# 결론: 모든 노드를 정확히 한 번씩 방문 → O(n)
#
# 예시:
#      A
#     / \
#    B   C
#   / \
#  D   E
#
# 호출 순서 (후위):
# 1. f(D): O(1)
# 2. f(E): O(1)
# 3. f(B): f(D) + f(E) + O(1)
# 4. f(C): O(1)
# 5. f(A): f(B) + f(C) + O(1)
#
# 총 호출: 5번 = 노드 개수
#
# 2. 공간복잡도: O(h)
#
# 분석:
# - h = 트리의 높이
# - 재귀 호출 스택의 깊이 = 최대 경로 길이
# - 한 번에 최대 h개의 호출이 스택에 존재
#
# 상세:
# - 리프까지 내려갔다가 돌아오는 구조
# - 최악의 경우: 루트에서 가장 깊은 리프까지
# - 스택 프레임: O(h)개
#
# 경우별 공간복잡도:
#
# a) 균형 트리:
# - 높이 h = log₂(n)
# - 공간: O(log n)
#
# 예: 완전 이진 트리 (n=7, h=2)
#      A
#     / \
#    B   C
#   / \ / \
#  D  E F  G
#
# 최대 스택: A → B → D (3개 = h+1)
#
# b) 편향 트리:
# - 높이 h = n - 1
# - 공간: O(n)
#
# 예: 왼쪽 편향 (n=4, h=3)
#     A
#    /
#   B
#  /
# C
#/
#D
#
# 최대 스택: A → B → C → D (4개 = n)
#
# 3. 복잡도 요약
#
# | 경우 | 시간 | 공간 |
# |------|------|------|
# | 균형 트리 | O(n) | O(log n) |
# | 편향 트리 | O(n) | O(n) |
# | 일반 | O(n) | O(h) |
#
# 4. 다른 방법과 비교
#
# a) 반복문 + 스택:
# def height_iterative(s, root):
#     stack = [(root, 0)]
#     max_h = -1
#     while stack:
#         node, h = stack.pop()
#         if node >= len(s) or s[node] == '-':
#             continue
#         max_h = max(max_h, h)
#         stack.append((node*2, h+1))
#         stack.append((node*2+1, h+1))
#     return max_h
#
# - 시간: O(n)
# - 공간: O(n) (스택에 모든 노드 가능)
# - 재귀보다 공간 효율 나쁨
#
# b) BFS (레벨 순서):
# def height_bfs(s, root):
#     queue = [root]
#     h = -1
#     while queue:
#         h += 1
#         for _ in range(len(queue)):
#             node = queue.pop(0)
#             if node >= len(s) or s[node] == '-':
#                 continue
#             queue.append(node*2)
#             queue.append(node*2+1)
#     return h
#
# - 시간: O(n)
# - 공간: O(w) (w = 최대 너비)
# - 완전 트리에서 w ≈ n/2 → O(n)
#
# 5. 최적화
#
# 메모이제이션 (여러 번 호출 시):
# memo = {}
# def height_memo(s, n):
#     if n in memo:
#         return memo[n]
#     if n >= len(s) or s[n] == '-':
#         return -1
#     l = height_memo(s, n*2)
#     r = height_memo(s, n*2+1)
#     memo[n] = max(l, r) + 1
#     return memo[n]
#
# - 첫 호출: O(n)
# - 이후 호출: O(1)
# - 공간: O(n) (메모 저장)
#
# 6. 실무 고려사항
#
# - Python 재귀 깊이 제한: 기본 1000
# - 깊은 트리(h > 1000)는 반복문 사용
# - 균형 트리라면 재귀가 안전하고 깔끔
# - 입력 트리가 편향 가능성 → 반복문 고려
#
# 결론:
# - 시간: 항상 O(n) (모든 노드 방문 필요)
# - 공간: O(h) (재귀 스택)
#   - 균형: O(log n)
#   - 편향: O(n)]]></solution>
  </problem>
</problems>
