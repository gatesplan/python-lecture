<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: 출력 예측 (순열 생성) - 워밍업 -->
  <problem>
    <description>다음 순열 생성 코드의 출력 결과를 쓰세요.</description>
    <code><![CDATA[def f(n, z, used):
    if len(z) == n:
        print(z)
        return
    for i in range(1, n+1):
        if not used[i]:
            used[i] = True
            z.append(i)
            f(n, z, used)
            z.pop()
            used[i] = False

used = [False] * 4
f(3, [], used)]]></code>
    <input></input>
    <output><![CDATA[[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]]]></output>
    <solution><![CDATA[# 1부터 3까지의 모든 순열 생성
#
# 백트래킹 과정:
# - 첫 자리: 1, 2, 3 선택 가능
# - 두 번째 자리: 남은 것 중 선택
# - 세 번째 자리: 마지막 남은 것
#
# 총 3! = 6개의 순열
#
# 정답:
# [1, 2, 3]
# [1, 3, 2]
# [2, 1, 3]
# [2, 3, 1]
# [3, 1, 2]
# [3, 2, 1]]]></solution>
  </problem>

  <!-- 문제 2: 서술형 (백트래킹 응용 분야) -->
  <problem>
    <description>백트래킹 알고리즘이 사용되는 대표적인 문제 5가지를 나열하고, 각각의 특징을 간단히 설명하세요.</description>
    <code></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 백트래킹의 대표적인 응용 분야
#
# ========================================
# 1. N-Queen 문제
# ========================================
# - N×N 체스판에 N개의 퀸을 배치
# - 서로 공격하지 않는 위치 찾기
# - 각 행/열/대각선에 하나씩만 배치
# - 시간복잡도: O(N!)
#
# ========================================
# 2. 순열/조합 생성
# ========================================
# - 주어진 원소들의 모든 순열 또는 조합 생성
# - used 배열로 중복 방지
# - 순열: O(N!), 조합: O(2^N)
# - 예: [1,2,3]의 모든 순열
#
# ========================================
# 3. 해밀토니안 경로/사이클
# ========================================
# - 모든 노드를 정확히 한 번씩 방문
# - 그래프 이론 문제
# - visited 배열로 방문 관리
# - 시간복잡도: O(V!)
#
# ========================================
# 4. 미로 찾기 (Maze Solving)
# ========================================
# - 시작점에서 도착점까지 경로 찾기
# - 4방향 또는 8방향 탐색
# - visited로 중복 방지
# - 모든 경로 또는 최단 경로 탐색
#
# ========================================
# 5. 스도쿠 (Sudoku)
# ========================================
# - 9×9 격자에 1-9 숫자 채우기
# - 행/열/3×3 블록에 중복 없이
# - 빈 칸마다 1-9 시도하며 백트래킹
# - 제약 조건 만족 문제 (CSP)
#
# ========================================
# 기타 응용
# ========================================
# - 부분집합의 합 (Subset Sum)
# - 그래프 색칠 (Graph Coloring)
# - 배낭 문제 변형 (Knapsack variants)
# - 문자열 분할 (String Partitioning)
# - 기사의 여행 (Knight's Tour)
#
# ========================================
# 공통 특징
# ========================================
# - 모든 가능한 해를 탐색
# - 조건 위반 시 조기 종료 (가지치기)
# - 상태 변경과 복원의 대칭성
# - 대부분 지수 시간 복잡도]]></solution>
  </problem>

  <!-- 문제 3: 빈칸 채우기 (미로 탐색) -->
  <problem>
    <description>미로 탐색에서 4방향 이동을 구현하세요. 빈칸을 채우세요.</description>
    <code><![CDATA[dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

def f(x, y):
    global M, visited
    if x == ex and y == ey:
        return True
    visited[x][y] = True
    for i in range(4):
        nx = ____
        ny = ____
        if 0 <= nx < n and 0 <= ny < n:
            if M[nx][ny] == 0 and not visited[nx][ny]:
                if f(nx, ny):
                    return True
    ____ = False
    return False]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

def f(x, y):
    global M, visited
    if x == ex and y == ey:
        return True
    visited[x][y] = True
    for i in range(4):
        nx = x + dx[i]  # 정답: x + dx[i]
        ny = y + dy[i]  # 정답: y + dy[i]
        if 0 <= nx < n and 0 <= ny < n:
            if M[nx][ny] == 0 and not visited[nx][ny]:
                if f(nx, ny):
                    return True
    visited[x][y] = False  # 정답: visited[x][y]
    return False

# 4방향 이동:
# dx, dy 배열을 사용하여 상하좌우 표현
# - (0, 1): 오른쪽
# - (1, 0): 아래
# - (0, -1): 왼쪽
# - (-1, 0): 위
#
# 백트래킹:
# - visited[x][y] = True (진입)
# - 4방향 탐색
# - visited[x][y] = False (복원)]]></solution>
  </problem>

  <!-- 문제 4: 디버깅 (순열 중복) -->
  <problem>
    <description>다음 순열 생성 코드는 중복된 결과를 출력합니다. 오류를 찾아 고치세요.</description>
    <code><![CDATA[def f(n, z):
    if len(z) == n:
        print(z)
        return
    for i in range(1, n+1):
        z.append(i)
        f(n, z)
        z.pop()]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[def f(n, z, used):  # used 파라미터 추가
    if len(z) == n:
        print(z)
        return
    for i in range(1, n+1):
        if not used[i]:  # 오류: 사용 여부 확인 없음
            used[i] = True  # 사용 표시
            z.append(i)
            f(n, z, used)  # used 전달
            z.pop()
            used[i] = False  # 사용 해제

# 잘못된 부분: used 배열 없음
#
# 문제점:
# - 같은 숫자를 여러 번 사용 가능
# - [1, 1, 1], [1, 1, 2] 같은 중복 순열 생성
# - 순열이 아니라 중복순열이 됨
#
# 해결:
# - used 배열로 각 숫자의 사용 여부 추적
# - 사용한 숫자는 다시 선택 불가
# - 백트래킹으로 used[i] = False 복원
#
# 초기 호출:
# used = [False] * (n+1)
# f(n, [], used)
#
# 순열 vs 중복순열:
# - 순열: 같은 원소 한 번만 (used 필요)
# - 중복순열: 같은 원소 여러 번 (used 불필요)]]></solution>
  </problem>

  <!-- 문제 5: 전체 작성 (순열 생성) -->
  <problem>
    <description>1부터 n까지의 숫자로 만들 수 있는 모든 순열을 생성하는 재귀 함수를 작성하세요.</description>
    <code><![CDATA[def f(n, z, used):
    pass]]></code>
    <input><![CDATA[used = [False] * 5
f(4, [], used)]]></input>
    <output><![CDATA[[1, 2, 3, 4]
[1, 2, 4, 3]
[1, 3, 2, 4]
[1, 3, 4, 2]
[1, 4, 2, 3]
[1, 4, 3, 2]
[2, 1, 3, 4]
[2, 1, 4, 3]
[2, 3, 1, 4]
[2, 3, 4, 1]
[2, 4, 1, 3]
[2, 4, 3, 1]
[3, 1, 2, 4]
[3, 1, 4, 2]
[3, 2, 1, 4]
[3, 2, 4, 1]
[3, 4, 1, 2]
[3, 4, 2, 1]
[4, 1, 2, 3]
[4, 1, 3, 2]
[4, 2, 1, 3]
[4, 2, 3, 1]
[4, 3, 1, 2]
[4, 3, 2, 1]]]></output>
    <solution><![CDATA[def f(n, z, used):
    # 종료 조건: n개 모두 선택
    if len(z) == n:
        print(z)
        return

    # 1부터 n까지 시도
    for i in range(1, n+1):
        # 아직 사용하지 않은 숫자만
        if not used[i]:
            # 선택
            used[i] = True
            z.append(i)

            # 탐색
            f(n, z, used)

            # 복원
            z.pop()
            used[i] = False

# 순열 생성 백트래킹 패턴:
# 1. 종료 조건: len(z) == n
# 2. 반복: 1부터 n까지
# 3. 조건: not used[i]
# 4. 백트래킹: used, z 복원
#
# 시간복잡도: O(N!)
# - N=4: 24개 순열
# - N=5: 120개 순열
# - N=10: 3,628,800개 순열]]></solution>
  </problem>

  <!-- 문제 6: 트레이싱 (N-Queen 4x4) -->
  <problem>
    <description>4×4 체스판에서 4개의 퀸을 배치하는 문제입니다. 가능한 해가 총 몇 개인지 구하세요. (회전/대칭 포함)</description>
    <code><![CDATA[cnt = 0

def f(r, cols, d1, d2):
    global cnt
    if r == 4:
        cnt += 1
        return
    for c in range(4):
        if c not in cols and r-c not in d1 and r+c not in d2:
            f(r+1, cols | {c}, d1 | {r-c}, d2 | {r+c})

f(0, set(), set(), set())
print(cnt)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 4-Queen 문제 분석
#
# cols: 열 사용 여부
# d1: 왼쪽 대각선 (r-c)
# d2: 오른쪽 대각선 (r+c)
#
# 가능한 배치 2가지:
#
# 해 1:
# . Q . .   (0,1)
# . . . Q   (1,3)
# Q . . .   (2,0)
# . . Q .   (3,2)
#
# 해 2:
# . . Q .   (0,2)
# Q . . .   (1,0)
# . . . Q   (2,3)
# . Q . .   (3,1)
#
# 정답: 2
#
# N-Queen 해의 개수:
# N=1: 1
# N=2: 0
# N=3: 0
# N=4: 2
# N=5: 10
# N=6: 4
# N=7: 40
# N=8: 92
#
# 백트래킹 과정:
# - 각 행마다 퀸을 하나씩 배치
# - 같은 열, 대각선에 있으면 배치 불가
# - 4개 모두 배치하면 cnt 증가
# - 모든 가능성을 탐색]]></solution>
  </problem>

  <!-- 문제 7: 전체 작성 (그래프 경로) -->
  <problem>
    <description>그래프에서 시작 노드 s에서 도착 노드 e까지 가는 모든 경로를 출력하는 재귀 함수를 작성하세요. 같은 노드를 두 번 방문하면 안 됩니다.</description>
    <code><![CDATA[def f(x, e, path, visited):
    pass]]></code>
    <input><![CDATA[G = [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]
visited = [False] * 4
f(0, 3, [0], visited)]]></input>
    <output><![CDATA[[0, 1, 2, 3]
[0, 1, 3]
[0, 2, 1, 3]
[0, 2, 3]]]></output>
    <solution><![CDATA[def f(x, e, path, visited):
    # 종료 조건: 도착점 도달
    if x == e:
        print(path)
        return

    # 현재 노드 방문 표시
    visited[x] = True

    # 인접 노드 탐색
    for u in G[x]:
        # 미방문 노드만
        if not visited[u]:
            # 경로 추가
            path.append(u)
            # 재귀 호출
            f(u, e, path, visited)
            # 백트래킹
            path.pop()

    # 방문 표시 해제
    visited[x] = False

# 그래프 경로 탐색:
# - 시작점에서 도착점까지 모든 경로 찾기
# - visited로 중복 방문 방지
# - path에 현재까지의 경로 저장
#
# 그래프 구조:
#   0 --- 1
#   |     |\
#   |     | \
#   2 --- 3
#
# 가능한 경로 (0 → 3):
# 1. 0 → 1 → 2 → 3
# 2. 0 → 1 → 3
# 3. 0 → 2 → 1 → 3
# 4. 0 → 2 → 3
#
# 백트래킹 핵심:
# - visited[x] = True/False
# - path.append(u) / path.pop()
# - 모든 경로를 빠짐없이 탐색]]></solution>
  </problem>

  <!-- 문제 8: 복잡도 분석 (N-Queen) -->
  <problem>
    <description>N-Queen 문제의 시간복잡도를 분석하고, N=8, 12일 때 대략적인 탐색 횟수를 설명하세요.</description>
    <code><![CDATA[def f(r, cols, d1, d2):
    if r == N:
        return 1
    cnt = 0
    for c in range(N):
        if c not in cols and r-c not in d1 and r+c not in d2:
            cnt += f(r+1, cols | {c}, d1 | {r-c}, d2 | {r+c})
    return cnt]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# ========================================
# N-Queen 시간복잡도 분석
# ========================================
#
# 이론적 상한:
# - 첫 번째 행: N개 선택
# - 두 번째 행: 최대 N-1개
# - 세 번째 행: 최대 N-2개
# - ...
# - 상한: O(N!)
#
# 실제 복잡도:
# - 대각선 제약으로 선택지가 더 제한됨
# - 가지치기 효과로 실제로는 N!보다 훨씬 적음
# - 대략 O(N^N) 수준이지만 가지치기로 개선
#
# ========================================
# 탐색 횟수 추정
# ========================================
#
# N=8:
# - 이론적: 8! = 40,320
# - 실제 탐색: 약 2,057개 노드 방문
# - 유효한 해: 92개
# - 가지치기 효과: 약 95% 감소
#
# N=12:
# - 이론적: 12! = 479,001,600
# - 실제 탐색: 약 341,680개 노드 방문
# - 유효한 해: 14,200개
# - 가지치기 효과: 약 99.9% 감소
#
# ========================================
# 가지치기 효과 분석
# ========================================
#
# 제약 조건:
# 1. cols: 같은 열에 퀸 배치 불가
# 2. d1: 왼쪽 대각선 (\) 공격 불가
# 3. d2: 오른쪽 대각선 (/) 공격 불가
#
# 각 행마다:
# - 평균적으로 절반 이상의 위치가 제외됨
# - 깊이가 깊어질수록 선택지 급격히 감소
# - 조기 종료로 불필요한 탐색 생략
#
# ========================================
# 복잡도 비교
# ========================================
#
# 완전 탐색 (N^N):
# - N=8: 8^8 = 16,777,216
# - 모든 위치에 퀸 배치 시도
#
# 팩토리얼 (N!):
# - N=8: 8! = 40,320
# - 각 행에 하나씩만 배치
#
# 백트래킹 (실제):
# - N=8: 약 2,057
# - 제약 조건으로 가지치기
#
# ========================================
# 실제 해의 개수
# ========================================
#
# N=1: 1
# N=2: 0 (불가능)
# N=3: 0 (불가능)
# N=4: 2
# N=5: 10
# N=6: 4
# N=7: 40
# N=8: 92
# N=9: 352
# N=10: 724
# N=11: 2,680
# N=12: 14,200
#
# ========================================
# 최적화 기법
# ========================================
#
# 1. 비트 마스킹:
#    - set 대신 비트 연산 사용
#    - 메모리 절약, 속도 향상
#
# 2. 대칭성 활용:
#    - 회전/대칭 제거하면 8배 감소
#    - N=8: 92 → 12 (기본 해)
#
# 3. 휴리스틱:
#    - 선택지 적은 행부터 탐색
#    - 실패 가능성 높은 것 먼저 제거
#
# ========================================
# 결론
# ========================================
#
# - 이론적: O(N!)
# - 실제: 가지치기로 훨씬 개선
# - N=12 정도까지 실용적
# - N > 20은 최적화 필요
# - 백트래킹의 강력한 가지치기 효과 확인]]></solution>
  </problem>
</problems>
