<?xml version="1.0" encoding="UTF-8"?>
<problems>
  <!-- 문제 1: 파라미터 의미 서술 -->
  <problem>
    <description>다음 재귀 함수 f의 세 파라미터 k, s, j가 각각 무엇을 의미하는지 서술하세요.</description>
    <code><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return

    for i in range(k+1, 8):
        f(i, s+A[i], j+1)

    return

f(0, 0, 0)
print(ans)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 파라미터 의미:
# k: 현재까지 탐색한 인덱스 (마지막으로 선택한 원소의 인덱스)
# s: 현재까지 선택한 숫자들의 합
# j: 현재까지 선택한 숫자의 개수 (깊이)]]></solution>
  </problem>

  <!-- 문제 2: 종료 조건 두 if 빈칸 채우기 -->
  <problem>
    <description>다음 코드는 배열에서 3개를 선택하여 합이 3의 배수인 경우 중 최댓값을 구하는 재귀 함수입니다. 두 if문의 조건을 완성하세요.</description>
    <code><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if ____:  # 여기를 채우세요
        if ____:  # 여기를 채우세요
            global ans
            ans = max(ans, s)
        return

    for i in range(k+1, 8):
        f(i, s+A[i], j+1)

    return

f(0, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[33]]></output>
    <solution><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return

    for i in range(k+1, 8):
        f(i, s+A[i], j+1)

    return

f(0, 0, 0)
print(ans)]]></solution>
  </problem>

  <!-- 문제 3: ans 업데이트와 range 빈칸 채우기 -->
  <problem>
    <description>다음 코드는 배열에서 3개를 선택하여 합이 3의 배수인 경우 중 최댓값을 구하는 재귀 함수입니다. ans 업데이트 부분과 range 빈칸을 완성하세요.</description>
    <code><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = ____  # 여기를 채우세요
        return

    for i in range(____, 8):  # 여기를 채우세요
        f(i, s+A[i], j+1)

    return

f(0, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[33]]></output>
    <solution><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return

    for i in range(k+1, 8):
        f(i, s+A[i], j+1)

    return

f(0, 0, 0)
print(ans)]]></solution>
  </problem>

  <!-- 문제 4: 재귀 호출 빈칸 채우기 -->
  <problem>
    <description>다음 코드는 배열에서 3개를 선택하여 합이 3의 배수인 경우 중 최댓값을 구하는 재귀 함수입니다. 재귀 호출의 세 인자를 완성하세요.</description>
    <code><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return

    for i in range(k+1, 8):
        f(____, ____, ____)  # 여기를 채우세요

    return

f(0, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[33]]></output>
    <solution><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return

    for i in range(k+1, 8):
        f(i, s+A[i], j+1)

    return

f(0, 0, 0)
print(ans)]]></solution>
  </problem>

  <!-- 문제 5: if j == 3 블록 전체 작성 -->
  <problem>
    <description>다음 코드는 배열에서 3개를 선택하여 합이 3의 배수인 경우 중 최댓값을 구하는 재귀 함수입니다. 종료 조건 블록을 완성하세요.</description>
    <code><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        # 여기를 채우세요
        return

    for i in range(k+1, 8):
        f(i, s+A[i], j+1)

    return

f(0, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[33]]></output>
    <solution><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return

    for i in range(k+1, 8):
        f(i, s+A[i], j+1)

    return

f(0, 0, 0)
print(ans)]]></solution>
  </problem>

  <!-- 문제 6: for 블록 전체 작성 -->
  <problem>
    <description>다음 코드는 배열에서 3개를 선택하여 합이 3의 배수인 경우 중 최댓값을 구하는 재귀 함수입니다. for 반복문 내부를 완성하세요.</description>
    <code><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return

    for i in range(k+1, 8):
        # 여기를 채우세요

    return

f(0, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[33]]></output>
    <solution><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return

    for i in range(k+1, 8):
        f(i, s+A[i], j+1)

    return

f(0, 0, 0)
print(ans)]]></solution>
  </problem>

  <!-- 문제 7: 함수 전체 작성 -->
  <problem>
    <description>배열에서 3개를 선택하여 합이 3의 배수인 경우 중 최댓값을 구하는 재귀 함수를 작성하세요.</description>
    <code><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    # 여기를 채우세요
    pass

f(0, 0, 0)
print(ans)]]></code>
    <input></input>
    <output><![CDATA[33]]></output>
    <solution><![CDATA[A = [0, 1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return

    for i in range(k+1, 8):
        f(i, s+A[i], j+1)

    return

f(0, 0, 0)
print(ans)]]></solution>
  </problem>

  <!-- 문제 8: 잠재 버그 찾기 -->
  <problem>
    <description>다음 코드는 패딩 없는 배열에서 동작하도록 수정된 버전입니다. 잠재적 버그가 있다면 무엇인지 찾고, 수정 방법을 서술하세요.</description>
    <code><![CDATA[A = [1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return

    for i in range(k+1, 7):
        f(i, s+A[i], j+1)

    return

f(-1, 0, 0)
print(ans)]]></code>
    <input></input>
    <output></output>
    <solution><![CDATA[# 잠재적 버그:
# range(k+1, 7)에서 배열 길이가 7이므로 인덱스 0~6을 사용해야 함
# 하지만 range(k+1, 7)은 최대 range(6, 7) = [6]만 반복
# 마지막 원소만 탐색하고 끝나는 버그 발생

# 수정 방법:
# 1. range(k+1, len(A)) 사용
# 2. 또는 range(k+1, 7) → range(k+1, 7) 유지하되 확인 필요

# 실제 정상 코드:
A = [1, 2, 7, 9, 10, 15, 16]
ans = -1

def f(k, s, j):
    if j == 3:
        if (s%3) == 0:
            global ans
            ans = max(ans, s)
        return

    for i in range(k+1, len(A)):  # len(A) 사용
        f(i, s+A[i], j+1)

    return

f(-1, 0, 0)
print(ans)]]></solution>
  </problem>
</problems>
